{"ast":null,"code":"import _defineProperty from \"/opt/tezos/nft-shop-example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"/opt/tezos/nft-shop-example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/opt/tezos/nft-shop-example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/opt/tezos/nft-shop-example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/opt/tezos/nft-shop-example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/opt/tezos/nft-shop-example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport * as sodium from 'libsodium-wrappers';\nimport axios from 'axios';\nimport { getHexHash, toHex, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload } from '../../utils/crypto';\nimport { MatrixClient } from '../../matrix-client/MatrixClient';\nimport { MatrixClientEventType } from '../../matrix-client/models/MatrixClientEvent';\nimport { MatrixMessageType } from '../../matrix-client/models/MatrixMessage';\nimport { PeerManager, StorageKey } from '../..';\nimport { BEACON_VERSION } from '../../constants';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { Logger } from '../../utils/Logger';\nimport { CommunicationClient } from './CommunicationClient';\nimport { ExposedPromise } from '../../utils/exposed-promise';\nvar logger = new Logger('P2PCommunicationClient');\nvar KNOWN_RELAY_SERVERS = ['beacon-node-1.sky.papers.tech', 'beacon-node-0.papers.tech:8448', 'beacon-node-2.sky.papers.tech'];\n\nvar publicKeyToNumber = function publicKeyToNumber(arr, mod) {\n  var sum = 0;\n\n  for (var i = 0; i < arr.length; i++) {\n    sum += arr[i] + i;\n  }\n\n  return Math.floor(sum % mod);\n};\n/**\n * @internalapi\n *\n *\n */\n\n\nexport var P2PCommunicationClient = /*#__PURE__*/function (_CommunicationClient) {\n  _inherits(P2PCommunicationClient, _CommunicationClient);\n\n  var _super = _createSuper(P2PCommunicationClient);\n\n  function P2PCommunicationClient(name, keyPair, replicationCount, storage, matrixNodes, iconUrl, appUrl) {\n    var _this;\n\n    _classCallCheck(this, P2PCommunicationClient);\n\n    _this = _super.call(this, keyPair);\n    _this.name = name;\n    _this.replicationCount = replicationCount;\n    _this.storage = storage;\n    _this.iconUrl = iconUrl;\n    _this.appUrl = appUrl;\n    _this.client = new ExposedPromise();\n    _this.activeListeners = new Map();\n    _this.ignoredRooms = [];\n    _this.loginCounter = 0;\n    logger.log('constructor', 'P2PCommunicationClient created');\n    _this.KNOWN_RELAY_SERVERS = matrixNodes.length > 0 ? matrixNodes : KNOWN_RELAY_SERVERS;\n    return _this;\n  }\n\n  _createClass(P2PCommunicationClient, [{\n    key: \"getPairingRequestInfo\",\n    value: function getPairingRequestInfo() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var info;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return generateGUID();\n\n              case 2:\n                _context.t0 = _context.sent;\n                _context.t1 = this.name;\n                _context.t2 = BEACON_VERSION;\n                _context.next = 7;\n                return this.getPublicKey();\n\n              case 7:\n                _context.t3 = _context.sent;\n                _context.next = 10;\n                return this.getRelayServer();\n\n              case 10:\n                _context.t4 = _context.sent;\n                info = {\n                  id: _context.t0,\n                  type: 'p2p-pairing-request',\n                  name: _context.t1,\n                  version: _context.t2,\n                  publicKey: _context.t3,\n                  relayServer: _context.t4\n                };\n\n                if (this.iconUrl) {\n                  info.icon = this.iconUrl;\n                }\n\n                if (this.appUrl) {\n                  info.appUrl = this.appUrl;\n                }\n\n                return _context.abrupt(\"return\", info);\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"getPairingResponseInfo\",\n    value: function getPairingResponseInfo(request) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var info;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.t0 = request.id;\n                _context2.t1 = this.name;\n                _context2.t2 = BEACON_VERSION;\n                _context2.next = 5;\n                return this.getPublicKey();\n\n              case 5:\n                _context2.t3 = _context2.sent;\n                _context2.next = 8;\n                return this.getRelayServer();\n\n              case 8:\n                _context2.t4 = _context2.sent;\n                info = {\n                  id: _context2.t0,\n                  type: 'p2p-pairing-response',\n                  name: _context2.t1,\n                  version: _context2.t2,\n                  publicKey: _context2.t3,\n                  relayServer: _context2.t4\n                };\n\n                if (this.iconUrl) {\n                  info.icon = this.iconUrl;\n                }\n\n                if (this.appUrl) {\n                  info.appUrl = this.appUrl;\n                }\n\n                return _context2.abrupt(\"return\", info);\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"getRelayServer\",\n    value: function getRelayServer() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var node, hasDoneMigration, preservedState, _node, startIndex, offset, serverIndex, server;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this.relayServer) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this.relayServer.promise);\n\n              case 4:\n                this.relayServer = new ExposedPromise();\n\n              case 5:\n                _context3.next = 7;\n                return this.storage.get(StorageKey.MATRIX_SELECTED_NODE);\n\n              case 7:\n                node = _context3.sent;\n\n                if (!(node && node.length > 0)) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                this.relayServer.resolve(node);\n                return _context3.abrupt(\"return\", node);\n\n              case 13:\n                if (!(KNOWN_RELAY_SERVERS === this.KNOWN_RELAY_SERVERS)) {\n                  _context3.next = 28;\n                  break;\n                }\n\n                _context3.next = 16;\n                return this.storage.get(StorageKey.MULTI_NODE_SETUP_DONE);\n\n              case 16:\n                hasDoneMigration = _context3.sent;\n\n                if (hasDoneMigration) {\n                  _context3.next = 28;\n                  break;\n                }\n\n                _context3.next = 20;\n                return this.storage.get(StorageKey.MATRIX_PRESERVED_STATE);\n\n              case 20:\n                preservedState = _context3.sent;\n                console.log('PRESERVED STATE', preservedState);\n\n                if (!(preservedState.syncToken || preservedState.rooms)) {\n                  _context3.next = 27;\n                  break;\n                }\n\n                // If migration has NOT run and we have a sync state, we know have been previously connected. So we set the old default relayServer as our current node.\n                _node = 'matrix.papers.tech'; // 2.2.7 Migration: This will default to the old default to avoid peers from losing their relayServer.\n\n                this.storage.set(StorageKey.MATRIX_SELECTED_NODE, _node).catch(function (error) {\n                  return logger.log(error);\n                });\n                this.relayServer.resolve(_node);\n                return _context3.abrupt(\"return\", _node);\n\n              case 27:\n                this.storage.set(StorageKey.MULTI_NODE_SETUP_DONE, true).catch(function (error) {\n                  return logger.log(error);\n                }); // Migration end\n\n              case 28:\n                console.log('GET RELAY SERVER');\n                startIndex = publicKeyToNumber(this.keyPair.publicKey, this.KNOWN_RELAY_SERVERS.length);\n                offset = 0;\n\n              case 31:\n                if (!(offset < this.KNOWN_RELAY_SERVERS.length)) {\n                  _context3.next = 48;\n                  break;\n                }\n\n                serverIndex = (startIndex + offset) % this.KNOWN_RELAY_SERVERS.length;\n                server = this.KNOWN_RELAY_SERVERS[serverIndex];\n                _context3.prev = 34;\n                _context3.next = 37;\n                return axios.get(\"https://\".concat(server, \"/_matrix/client/versions\"));\n\n              case 37:\n                this.storage.set(StorageKey.MATRIX_SELECTED_NODE, server).catch(function (error) {\n                  return logger.log(error);\n                });\n                this.relayServer.resolve(server);\n                return _context3.abrupt(\"return\", server);\n\n              case 42:\n                _context3.prev = 42;\n                _context3.t0 = _context3[\"catch\"](34);\n                logger.log(\"Ignoring server \\\"\".concat(server, \"\\\", trying another one...\"));\n                offset++;\n\n              case 46:\n                _context3.next = 31;\n                break;\n\n              case 48:\n                this.relayServer.reject(\"No matrix server reachable!\");\n                throw new Error(\"No matrix server reachable!\");\n\n              case 50:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[34, 42]]);\n      }));\n    }\n  }, {\n    key: \"tryJoinRooms\",\n    value: function tryJoinRooms(roomId) {\n      var retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                _context5.next = 3;\n                return this.client.promise;\n\n              case 3:\n                _context5.next = 5;\n                return _context5.sent.joinRooms(roomId);\n\n              case 5:\n                _context5.next = 10;\n                break;\n\n              case 7:\n                _context5.prev = 7;\n                _context5.t0 = _context5[\"catch\"](0);\n\n                if (retry <= 10 && _context5.t0.errcode === 'M_FORBIDDEN') {\n                  // If we join the room too fast after receiving the invite, the server can accidentally reject our join. This seems to be a problem only when using a federated multi-node setup. Usually waiting for a couple milliseconds solves the issue, but to handle lag, we will keep retrying for 2 seconds.\n                  logger.log(\"Retrying to join...\", _context5.t0);\n                  setTimeout(function () {\n                    return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n                      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                        while (1) {\n                          switch (_context4.prev = _context4.next) {\n                            case 0:\n                              _context4.next = 2;\n                              return this.tryJoinRooms(roomId, retry + 1);\n\n                            case 2:\n                            case \"end\":\n                              return _context4.stop();\n                          }\n                        }\n                      }, _callee4, this);\n                    }));\n                  }, 200);\n                } else {\n                  logger.log(\"Failed to join after \".concat(retry, \" tries.\"), _context5.t0);\n                }\n\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 7]]);\n      }));\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var _this3 = this;\n\n        var loginRawDigest, rawSignature, relayServer, client;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                logger.log('start', 'starting client');\n                _context8.next = 3;\n                return sodium.ready;\n\n              case 3:\n                loginRawDigest = sodium.crypto_generichash(32, sodium.from_string(\"login:\".concat(Math.floor(Date.now() / 1000 / (5 * 60)))));\n                rawSignature = sodium.crypto_sign_detached(loginRawDigest, this.keyPair.privateKey);\n                logger.log('start', \"connecting to server\");\n                _context8.next = 8;\n                return this.getRelayServer();\n\n              case 8:\n                relayServer = _context8.sent;\n                client = MatrixClient.create({\n                  baseUrl: \"https://\".concat(relayServer),\n                  storage: this.storage\n                });\n\n                this.initialListener = function (event) {\n                  return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n                    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            if (this.initialEvent && this.initialEvent.timestamp && event && event.timestamp) {\n                              if (this.initialEvent.timestamp < event.timestamp) {\n                                this.initialEvent = event;\n                              }\n                            } else {\n                              this.initialEvent = event;\n                            }\n\n                          case 1:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6, this);\n                  }));\n                };\n\n                client.subscribe(MatrixClientEventType.MESSAGE, this.initialListener);\n                client.subscribe(MatrixClientEventType.INVITE, function (event) {\n                  return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n                    var member;\n                    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n                      while (1) {\n                        switch (_context7.prev = _context7.next) {\n                          case 0:\n                            if (event.content.members.length === 1) {\n                              // If there is only one member we know it's a new room\n                              // TODO: Use the \"sender\" of the event instead\n                              member = event.content.members[0];\n                            }\n\n                            _context7.next = 3;\n                            return this.tryJoinRooms(event.content.roomId);\n\n                          case 3:\n                            if (!member) {\n                              _context7.next = 8;\n                              break;\n                            }\n\n                            _context7.next = 6;\n                            return this.updateRelayServer(member);\n\n                          case 6:\n                            _context7.next = 8;\n                            return this.updatePeerRoom(member, event.content.roomId);\n\n                          case 8:\n                          case \"end\":\n                            return _context7.stop();\n                        }\n                      }\n                    }, _callee7, this);\n                  }));\n                });\n                _context8.t0 = logger;\n                _context8.next = 16;\n                return this.getPublicKeyHash();\n\n              case 16:\n                _context8.t1 = _context8.sent;\n                _context8.t2 = relayServer;\n\n                _context8.t0.log.call(_context8.t0, 'start', 'login', _context8.t1, 'on', _context8.t2);\n\n                _context8.prev = 19;\n                _context8.t3 = client;\n                _context8.next = 23;\n                return this.getPublicKeyHash();\n\n              case 23:\n                _context8.t4 = _context8.sent;\n                _context8.t5 = \"ed:\".concat(toHex(rawSignature), \":\");\n                _context8.next = 27;\n                return this.getPublicKey();\n\n              case 27:\n                _context8.t6 = _context8.sent;\n                _context8.t7 = _context8.t5.concat.call(_context8.t5, _context8.t6);\n                _context8.t8 = toHex(this.keyPair.publicKey);\n                _context8.t9 = {\n                  id: _context8.t4,\n                  password: _context8.t7,\n                  deviceId: _context8.t8\n                };\n                _context8.next = 33;\n                return _context8.t3.start.call(_context8.t3, _context8.t9);\n\n              case 33:\n                _context8.next = 48;\n                break;\n\n              case 35:\n                _context8.prev = 35;\n                _context8.t10 = _context8[\"catch\"](19);\n                console.log('ERROR, RETRYING');\n                _context8.next = 40;\n                return this.reset();\n\n              case 40:\n                // If we can't log in, let's reset\n                console.log('TRYING AGAIN');\n\n                if (!(this.loginCounter <= this.KNOWN_RELAY_SERVERS.length)) {\n                  _context8.next = 47;\n                  break;\n                }\n\n                this.loginCounter++;\n                this.start();\n                return _context8.abrupt(\"return\");\n\n              case 47:\n                throw new Error('Too many login attempts. Try again later.');\n\n              case 48:\n                console.log('client is ready');\n                this.client.resolve(client);\n\n              case 50:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[19, 35]]);\n      }));\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!this.client.isResolved()) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                _context9.next = 3;\n                return this.client.promise;\n\n              case 3:\n                _context9.next = 5;\n                return _context9.sent.stop().catch(function (error) {\n                  return logger.error(error);\n                });\n\n              case 5:\n                _context9.next = 7;\n                return this.reset();\n\n              case 7:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.storage.delete(StorageKey.MATRIX_PEER_ROOM_IDS).catch(function (error) {\n                  return logger.log(error);\n                });\n\n              case 2:\n                _context10.next = 4;\n                return this.storage.delete(StorageKey.MATRIX_PRESERVED_STATE).catch(function (error) {\n                  return logger.log(error);\n                });\n\n              case 4:\n                _context10.next = 6;\n                return this.storage.delete(StorageKey.MATRIX_SELECTED_NODE).catch(function (error) {\n                  return logger.log(error);\n                });\n\n              case 6:\n                // Instead of resetting everything, maybe we should make sure a new instance is created?\n                this.relayServer = undefined;\n                this.client = new ExposedPromise();\n                this.initialEvent = undefined;\n                this.initialListener = undefined;\n\n              case 10:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n  }, {\n    key: \"listenForEncryptedMessage\",\n    value: function listenForEncryptedMessage(senderPublicKey, messageCallback) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var _this4 = this;\n\n        var _yield$this$createCry, sharedRx, callbackFunction, lastEvent, initialListener;\n\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (!this.activeListeners.has(senderPublicKey)) {\n                  _context12.next = 2;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\");\n\n              case 2:\n                _context12.next = 4;\n                return this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n\n              case 4:\n                _yield$this$createCry = _context12.sent;\n                sharedRx = _yield$this$createCry.sharedRx;\n\n                callbackFunction = function callbackFunction(event) {\n                  return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n                    var payload, decryptedMessage;\n                    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n                      while (1) {\n                        switch (_context11.prev = _context11.next) {\n                          case 0:\n                            _context11.t0 = this.isTextMessage(event.content);\n\n                            if (!_context11.t0) {\n                              _context11.next = 5;\n                              break;\n                            }\n\n                            _context11.next = 4;\n                            return this.isSender(event, senderPublicKey);\n\n                          case 4:\n                            _context11.t0 = _context11.sent;\n\n                          case 5:\n                            if (!_context11.t0) {\n                              _context11.next = 21;\n                              break;\n                            }\n\n                            _context11.next = 8;\n                            return this.updateRelayServer(event.content.message.sender);\n\n                          case 8:\n                            _context11.next = 10;\n                            return this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n\n                          case 10:\n                            try {\n                              payload = Buffer.from(event.content.message.content, 'hex'); // content can be non-hex if it's a connection open request\n                            } catch (_a) {\n                              /* */\n                            }\n\n                            if (!(payload && payload.length >= sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES)) {\n                              _context11.next = 21;\n                              break;\n                            }\n\n                            _context11.prev = 12;\n                            _context11.next = 15;\n                            return decryptCryptoboxPayload(payload, sharedRx);\n\n                          case 15:\n                            decryptedMessage = _context11.sent;\n                            // logger.log(\n                            //   'listenForEncryptedMessage',\n                            //   'encrypted message received',\n                            //   decryptedMessage,\n                            //   await new Serializer().deserialize(decryptedMessage)\n                            // )\n                            // console.log('calculated sender ID', await getSenderId(senderPublicKey))\n                            // TODO: Add check for correct decryption key / sender ID\n                            messageCallback(decryptedMessage);\n                            _context11.next = 21;\n                            break;\n\n                          case 19:\n                            _context11.prev = 19;\n                            _context11.t1 = _context11[\"catch\"](12);\n\n                          case 21:\n                          case \"end\":\n                            return _context11.stop();\n                        }\n                      }\n                    }, _callee11, this, [[12, 19]]);\n                  }));\n                };\n\n                this.activeListeners.set(senderPublicKey, callbackFunction);\n                _context12.next = 10;\n                return this.client.promise;\n\n              case 10:\n                _context12.sent.subscribe(MatrixClientEventType.MESSAGE, callbackFunction);\n\n                lastEvent = this.initialEvent;\n\n                if (!(lastEvent && lastEvent.timestamp && new Date().getTime() - lastEvent.timestamp < 5 * 60 * 1000)) {\n                  _context12.next = 18;\n                  break;\n                }\n\n                logger.log('listenForEncryptedMessage', 'Handling previous event');\n                _context12.next = 16;\n                return callbackFunction(lastEvent);\n\n              case 16:\n                _context12.next = 19;\n                break;\n\n              case 18:\n                logger.log('listenForEncryptedMessage', 'No previous event found');\n\n              case 19:\n                initialListener = this.initialListener;\n\n                if (!initialListener) {\n                  _context12.next = 25;\n                  break;\n                }\n\n                ;\n                _context12.next = 24;\n                return this.client.promise;\n\n              case 24:\n                _context12.sent.unsubscribe(MatrixClientEventType.MESSAGE, initialListener);\n\n              case 25:\n                this.initialListener = undefined;\n                this.initialEvent = undefined;\n\n              case 27:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n    }\n  }, {\n    key: \"unsubscribeFromEncryptedMessage\",\n    value: function unsubscribeFromEncryptedMessage(senderPublicKey) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var listener;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                listener = this.activeListeners.get(senderPublicKey);\n\n                if (listener) {\n                  _context13.next = 3;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\");\n\n              case 3:\n                ;\n                _context13.next = 6;\n                return this.client.promise;\n\n              case 6:\n                _context13.sent.unsubscribe(MatrixClientEventType.MESSAGE, listener);\n\n                this.activeListeners.delete(senderPublicKey);\n\n              case 8:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n    }\n  }, {\n    key: \"unsubscribeFromEncryptedMessages\",\n    value: function unsubscribeFromEncryptedMessages() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                ;\n                _context14.next = 3;\n                return this.client.promise;\n\n              case 3:\n                _context14.sent.unsubscribeAll(MatrixClientEventType.MESSAGE);\n\n                this.activeListeners.clear();\n\n              case 5:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n    }\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(message, peer) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {\n        var _this5 = this;\n\n        var _yield$this$createCry2, sharedTx, recipientHash, recipient, roomId, encryptedMessage;\n\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this.createCryptoBoxClient(peer.publicKey, this.keyPair.privateKey);\n\n              case 2:\n                _yield$this$createCry2 = _context17.sent;\n                sharedTx = _yield$this$createCry2.sharedTx;\n                _context17.next = 6;\n                return getHexHash(Buffer.from(peer.publicKey, 'hex'));\n\n              case 6:\n                recipientHash = _context17.sent;\n                recipient = recipientString(recipientHash, peer.relayServer);\n                _context17.next = 10;\n                return this.getRelevantRoom(recipient);\n\n              case 10:\n                roomId = _context17.sent;\n                _context17.next = 13;\n                return this.waitForJoin(roomId);\n\n              case 13:\n                _context17.next = 15;\n                return encryptCryptoboxPayload(message, sharedTx);\n\n              case 15:\n                encryptedMessage = _context17.sent;\n                _context17.next = 18;\n                return this.client.promise;\n\n              case 18:\n                _context17.sent.sendTextMessage(roomId, encryptedMessage).catch(function (error) {\n                  return __awaiter(_this5, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n                    var _this6 = this;\n\n                    var newRoomId;\n                    return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n                      while (1) {\n                        switch (_context16.prev = _context16.next) {\n                          case 0:\n                            if (!(error.errcode === 'M_FORBIDDEN')) {\n                              _context16.next = 12;\n                              break;\n                            }\n\n                            // Room doesn't exist\n                            logger.log(\"sendMessage\", \"M_FORBIDDEN\", error);\n                            _context16.next = 4;\n                            return this.deleteRoomIdFromRooms(roomId);\n\n                          case 4:\n                            _context16.next = 6;\n                            return this.getRelevantRoom(recipient);\n\n                          case 6:\n                            newRoomId = _context16.sent;\n                            _context16.next = 9;\n                            return this.client.promise;\n\n                          case 9:\n                            _context16.sent.sendTextMessage(newRoomId, encryptedMessage).catch(function (error2) {\n                              return __awaiter(_this6, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n                                return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n                                  while (1) {\n                                    switch (_context15.prev = _context15.next) {\n                                      case 0:\n                                        logger.log(\"sendMessage\", \"inner error\", error2);\n\n                                      case 1:\n                                      case \"end\":\n                                        return _context15.stop();\n                                    }\n                                  }\n                                }, _callee15);\n                              }));\n                            });\n\n                            _context16.next = 13;\n                            break;\n\n                          case 12:\n                            logger.log(\"sendMessage\", \"not forbidden\", error);\n\n                          case 13:\n                          case \"end\":\n                            return _context16.stop();\n                        }\n                      }\n                    }, _callee16, this);\n                  }));\n                });\n\n              case 19:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n    }\n  }, {\n    key: \"updatePeerRoom\",\n    value: function updatePeerRoom(sender, roomId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n        var split, roomIds, room;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n                split = sender.split(':');\n\n                if (!(split.length < 2 || !split[0].startsWith('@'))) {\n                  _context18.next = 3;\n                  break;\n                }\n\n                throw new Error('Invalid sender');\n\n              case 3:\n                _context18.next = 5;\n                return this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n\n              case 5:\n                roomIds = _context18.sent;\n                room = roomIds[sender];\n\n                if (room && room[1]) {\n                  // If we have a room already, let's ignore it. We need to do this, otherwise it will be loaded from the matrix cache.\n                  this.ignoredRooms.push(room[1]);\n                }\n\n                roomIds[sender] = roomId;\n                _context18.next = 11;\n                return this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n\n              case 11:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n    }\n  }, {\n    key: \"deleteRoomIdFromRooms\",\n    value: function deleteRoomIdFromRooms(roomId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee19() {\n        var roomIds, newRoomIds;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n\n              case 2:\n                roomIds = _context19.sent;\n                newRoomIds = Object.entries(roomIds).filter(function (entry) {\n                  return entry[1] !== roomId;\n                }).reduce(function (pv, cv) {\n                  return Object.assign(Object.assign({}, pv), _defineProperty({}, cv[0], cv[1]));\n                }, {});\n                _context19.next = 6;\n                return this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, newRoomIds);\n\n              case 6:\n                // TODO: We also need to delete the room from the sync state\n                // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n                this.ignoredRooms.push(roomId);\n\n              case 7:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n    }\n  }, {\n    key: \"listenForChannelOpening\",\n    value: function listenForChannelOpening(messageCallback) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee21() {\n        var _this7 = this;\n\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                ;\n                _context21.next = 3;\n                return this.client.promise;\n\n              case 3:\n                _context21.sent.subscribe(MatrixClientEventType.MESSAGE, function (event) {\n                  return __awaiter(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee20() {\n                    var splits, payload, pairingResponse;\n                    return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n                      while (1) {\n                        switch (_context20.prev = _context20.next) {\n                          case 0:\n                            _context20.t0 = this.isTextMessage(event.content);\n\n                            if (!_context20.t0) {\n                              _context20.next = 5;\n                              break;\n                            }\n\n                            _context20.next = 4;\n                            return this.isChannelOpenMessage(event.content);\n\n                          case 4:\n                            _context20.t0 = _context20.sent;\n\n                          case 5:\n                            if (!_context20.t0) {\n                              _context20.next = 33;\n                              break;\n                            }\n\n                            logger.log(\"listenForChannelOpening\", \"channel opening\", JSON.stringify(event));\n                            _context20.next = 9;\n                            return this.updateRelayServer(event.content.message.sender);\n\n                          case 9:\n                            _context20.next = 11;\n                            return this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n\n                          case 11:\n                            splits = event.content.message.content.split(':');\n                            payload = Buffer.from(splits[splits.length - 1], 'hex');\n\n                            if (!(payload.length >= sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES)) {\n                              _context20.next = 33;\n                              break;\n                            }\n\n                            _context20.prev = 14;\n                            _context20.t1 = JSON;\n                            _context20.next = 18;\n                            return openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey);\n\n                          case 18:\n                            _context20.t2 = _context20.sent;\n                            pairingResponse = _context20.t1.parse.call(_context20.t1, _context20.t2);\n                            _context20.t3 = messageCallback;\n                            _context20.t4 = Object;\n                            _context20.t5 = Object.assign({}, pairingResponse);\n                            _context20.next = 25;\n                            return getSenderId(pairingResponse.publicKey);\n\n                          case 25:\n                            _context20.t6 = _context20.sent;\n                            _context20.t7 = {\n                              senderId: _context20.t6\n                            };\n                            _context20.t8 = _context20.t4.assign.call(_context20.t4, _context20.t5, _context20.t7);\n                            (0, _context20.t3)(_context20.t8);\n                            _context20.next = 33;\n                            break;\n\n                          case 31:\n                            _context20.prev = 31;\n                            _context20.t9 = _context20[\"catch\"](14);\n\n                          case 33:\n                          case \"end\":\n                            return _context20.stop();\n                        }\n                      }\n                    }, _callee20, this, [[14, 31]]);\n                  }));\n                });\n\n              case 4:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n    }\n  }, {\n    key: \"waitForJoin\",\n    value: function waitForJoin(roomId) {\n      var retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee23() {\n        var _this8 = this;\n\n        var room;\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.next = 2;\n                return this.client.promise;\n\n              case 2:\n                _context23.next = 4;\n                return _context23.sent.getRoomById(roomId);\n\n              case 4:\n                room = _context23.sent;\n                logger.log(\"waitForJoin\", \"Currently \".concat(room.members.length, \" members, we need at least 2\"));\n\n                if (!(room.members.length >= 2 || room.members.length === 0)) {\n                  _context23.next = 10;\n                  break;\n                }\n\n                return _context23.abrupt(\"return\");\n\n              case 10:\n                if (!(retry <= 200)) {\n                  _context23.next = 15;\n                  break;\n                }\n\n                // On mobile, due to app switching, we potentially have to wait for a long time\n                logger.log(\"Waiting for join... Try: \".concat(retry));\n                return _context23.abrupt(\"return\", new Promise(function (resolve) {\n                  setTimeout(function () {\n                    return __awaiter(_this8, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee22() {\n                      return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n                        while (1) {\n                          switch (_context22.prev = _context22.next) {\n                            case 0:\n                              resolve(this.waitForJoin(roomId, retry + 1));\n\n                            case 1:\n                            case \"end\":\n                              return _context22.stop();\n                          }\n                        }\n                      }, _callee22, this);\n                    }));\n                  }, 100 * (retry > 50 ? 10 : 1)); // After the initial 5 seconds, retry only once per second\n                }));\n\n              case 15:\n                throw new Error(\"No one joined after \".concat(retry, \" tries.\"));\n\n              case 16:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n    }\n  }, {\n    key: \"sendPairingResponse\",\n    value: function sendPairingResponse(pairingRequest) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee26() {\n        var _this9 = this;\n\n        var recipientHash, recipient, roomId, message, encryptedMessage, msg;\n        return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                logger.log(\"sendPairingResponse\");\n                _context26.next = 3;\n                return getHexHash(Buffer.from(pairingRequest.publicKey, 'hex'));\n\n              case 3:\n                recipientHash = _context26.sent;\n                recipient = recipientString(recipientHash, pairingRequest.relayServer); // We force room creation here because if we \"re-pair\", we need to make sure that we don't send it to an old room.\n\n                _context26.next = 7;\n                return this.client.promise;\n\n              case 7:\n                _context26.next = 9;\n                return _context26.sent.createTrustedPrivateRoom(recipient);\n\n              case 9:\n                roomId = _context26.sent;\n                _context26.next = 12;\n                return this.updatePeerRoom(recipient, roomId);\n\n              case 12:\n                _context26.next = 14;\n                return this.waitForJoin(roomId);\n\n              case 14:\n                if (!(typeof pairingRequest.version === 'undefined')) {\n                  _context26.next = 20;\n                  break;\n                }\n\n                _context26.next = 17;\n                return this.getPublicKey();\n\n              case 17:\n                _context26.t0 = _context26.sent;\n                _context26.next = 25;\n                break;\n\n              case 20:\n                _context26.t1 = JSON;\n                _context26.next = 23;\n                return this.getPairingResponseInfo(pairingRequest);\n\n              case 23:\n                _context26.t2 = _context26.sent;\n                _context26.t0 = _context26.t1.stringify.call(_context26.t1, _context26.t2);\n\n              case 25:\n                message = _context26.t0;\n                _context26.next = 28;\n                return this.encryptMessageAsymmetric(pairingRequest.publicKey, message);\n\n              case 28:\n                encryptedMessage = _context26.sent;\n                msg = ['@channel-open', recipient, encryptedMessage].join(':');\n                _context26.next = 32;\n                return this.client.promise;\n\n              case 32:\n                _context26.sent.sendTextMessage(roomId, msg).catch(function (error) {\n                  return __awaiter(_this9, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee25() {\n                    var _this10 = this;\n\n                    var newRoomId;\n                    return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n                      while (1) {\n                        switch (_context25.prev = _context25.next) {\n                          case 0:\n                            if (!(error.errcode === 'M_FORBIDDEN')) {\n                              _context25.next = 12;\n                              break;\n                            }\n\n                            // Room doesn't exist\n                            logger.log(\"sendMessage\", \"M_FORBIDDEN\", error);\n                            _context25.next = 4;\n                            return this.deleteRoomIdFromRooms(roomId);\n\n                          case 4:\n                            _context25.next = 6;\n                            return this.getRelevantRoom(recipient);\n\n                          case 6:\n                            newRoomId = _context25.sent;\n                            _context25.next = 9;\n                            return this.client.promise;\n\n                          case 9:\n                            _context25.sent.sendTextMessage(newRoomId, msg).catch(function (error2) {\n                              return __awaiter(_this10, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee24() {\n                                return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n                                  while (1) {\n                                    switch (_context24.prev = _context24.next) {\n                                      case 0:\n                                        logger.log(\"sendMessage\", \"inner error\", error2);\n\n                                      case 1:\n                                      case \"end\":\n                                        return _context24.stop();\n                                    }\n                                  }\n                                }, _callee24);\n                              }));\n                            });\n\n                            _context25.next = 13;\n                            break;\n\n                          case 12:\n                            logger.log(\"sendMessage\", \"not forbidden\", error);\n\n                          case 13:\n                          case \"end\":\n                            return _context25.stop();\n                        }\n                      }\n                    }, _callee25, this);\n                  }));\n                });\n\n              case 33:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n    }\n  }, {\n    key: \"isTextMessage\",\n    value: function isTextMessage(content) {\n      return content.message.type === MatrixMessageType.TEXT;\n    }\n  }, {\n    key: \"updateRelayServer\",\n    value: function updateRelayServer(sender) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee28() {\n        var _this11 = this;\n\n        var split, senderHash, relayServer, manager, peers, promiseArray;\n        return _regeneratorRuntime.wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n                split = sender.split(':');\n\n                if (!(split.length < 2 || !split[0].startsWith('@'))) {\n                  _context28.next = 3;\n                  break;\n                }\n\n                throw new Error('Invalid sender');\n\n              case 3:\n                senderHash = split.shift();\n                relayServer = split.join(':');\n                manager = localStorage.getItem('beacon:communication-peers-dapp') ? new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_DAPP) : new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_WALLET);\n                _context28.next = 8;\n                return manager.getPeers();\n\n              case 8:\n                peers = _context28.sent;\n                promiseArray = peers.map(function (peer) {\n                  return __awaiter(_this11, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee27() {\n                    var hash;\n                    return _regeneratorRuntime.wrap(function _callee27$(_context27) {\n                      while (1) {\n                        switch (_context27.prev = _context27.next) {\n                          case 0:\n                            _context27.t0 = \"@\";\n                            _context27.next = 3;\n                            return getHexHash(Buffer.from(peer.publicKey, 'hex'));\n\n                          case 3:\n                            _context27.t1 = _context27.sent;\n                            hash = _context27.t0.concat.call(_context27.t0, _context27.t1);\n\n                            if (!(hash === senderHash)) {\n                              _context27.next = 10;\n                              break;\n                            }\n\n                            if (!(peer.relayServer !== relayServer)) {\n                              _context27.next = 10;\n                              break;\n                            }\n\n                            peer.relayServer = relayServer;\n                            _context27.next = 10;\n                            return manager.addPeer(peer);\n\n                          case 10:\n                          case \"end\":\n                            return _context27.stop();\n                        }\n                      }\n                    }, _callee27);\n                  }));\n                });\n                _context28.next = 12;\n                return Promise.all(promiseArray);\n\n              case 12:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n    }\n  }, {\n    key: \"isChannelOpenMessage\",\n    value: function isChannelOpenMessage(content) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee29() {\n        return _regeneratorRuntime.wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                _context29.t0 = content.message.content;\n                _context29.t1 = \"@channel-open:@\";\n                _context29.t2 = getHexHash;\n                _context29.t3 = Buffer;\n                _context29.next = 6;\n                return this.getPublicKey();\n\n              case 6:\n                _context29.t4 = _context29.sent;\n                _context29.t5 = _context29.t3.from.call(_context29.t3, _context29.t4, 'hex');\n                _context29.next = 10;\n                return (0, _context29.t2)(_context29.t5);\n\n              case 10:\n                _context29.t6 = _context29.sent;\n                _context29.t7 = _context29.t1.concat.call(_context29.t1, _context29.t6);\n                return _context29.abrupt(\"return\", _context29.t0.startsWith.call(_context29.t0, _context29.t7));\n\n              case 13:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29, this);\n      }));\n    }\n  }, {\n    key: \"isSender\",\n    value: function isSender(event, senderPublicKey) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee30() {\n        return _regeneratorRuntime.wrap(function _callee30$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                _context30.t0 = event.content.message.sender;\n                _context30.t1 = \"@\";\n                _context30.next = 4;\n                return getHexHash(Buffer.from(senderPublicKey, 'hex'));\n\n              case 4:\n                _context30.t2 = _context30.sent;\n                _context30.t3 = _context30.t1.concat.call(_context30.t1, _context30.t2);\n                return _context30.abrupt(\"return\", _context30.t0.startsWith.call(_context30.t0, _context30.t3));\n\n              case 7:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee30);\n      }));\n    }\n  }, {\n    key: \"getRelevantRoom\",\n    value: function getRelevantRoom(recipient) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee31() {\n        var roomIds, roomId, room;\n        return _regeneratorRuntime.wrap(function _callee31$(_context31) {\n          while (1) {\n            switch (_context31.prev = _context31.next) {\n              case 0:\n                _context31.next = 2;\n                return this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n\n              case 2:\n                roomIds = _context31.sent;\n                roomId = roomIds[recipient];\n\n                if (roomId) {\n                  _context31.next = 13;\n                  break;\n                }\n\n                logger.log(\"getRelevantRoom\", \"No room found for peer \".concat(recipient, \", checking joined ones.\"));\n                _context31.next = 8;\n                return this.getRelevantJoinedRoom(recipient);\n\n              case 8:\n                room = _context31.sent;\n                roomId = room.id;\n                roomIds[recipient] = room.id;\n                _context31.next = 13;\n                return this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n\n              case 13:\n                logger.log(\"getRelevantRoom\", \"Using room \".concat(roomId));\n                return _context31.abrupt(\"return\", roomId);\n\n              case 15:\n              case \"end\":\n                return _context31.stop();\n            }\n          }\n        }, _callee31, this);\n      }));\n    }\n  }, {\n    key: \"getRelevantJoinedRoom\",\n    value: function getRelevantJoinedRoom(recipient) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee32() {\n        var _this12 = this;\n\n        var joinedRooms, relevantRooms, room, roomId;\n        return _regeneratorRuntime.wrap(function _callee32$(_context32) {\n          while (1) {\n            switch (_context32.prev = _context32.next) {\n              case 0:\n                _context32.next = 2;\n                return this.client.promise;\n\n              case 2:\n                _context32.next = 4;\n                return _context32.sent.joinedRooms;\n\n              case 4:\n                joinedRooms = _context32.sent;\n                logger.log('checking joined rooms', joinedRooms, recipient);\n                relevantRooms = joinedRooms.filter(function (roomElement) {\n                  return !_this12.ignoredRooms.some(function (id) {\n                    return roomElement.id === id;\n                  });\n                }).filter(function (roomElement) {\n                  return roomElement.members.some(function (member) {\n                    return member === recipient;\n                  });\n                });\n\n                if (!(relevantRooms.length === 0 || this.ignoredRooms.length > 0)) {\n                  _context32.next = 25;\n                  break;\n                }\n\n                logger.log(\"getRelevantJoinedRoom\", \"no relevant rooms found, creating new one\");\n                _context32.next = 11;\n                return this.client.promise;\n\n              case 11:\n                _context32.next = 13;\n                return _context32.sent.createTrustedPrivateRoom(recipient);\n\n              case 13:\n                roomId = _context32.sent;\n                _context32.next = 16;\n                return this.client.promise;\n\n              case 16:\n                _context32.next = 18;\n                return _context32.sent.getRoomById(roomId);\n\n              case 18:\n                room = _context32.sent;\n                logger.log(\"getRelevantJoinedRoom\", \"waiting for other party to join room: \".concat(room.id));\n                _context32.next = 22;\n                return this.waitForJoin(roomId);\n\n              case 22:\n                logger.log(\"getRelevantJoinedRoom\", \"new room created and peer invited: \".concat(room.id));\n                _context32.next = 27;\n                break;\n\n              case 25:\n                room = relevantRooms[0];\n                logger.log(\"getRelevantJoinedRoom\", \"channel already open, reusing room \".concat(room.id));\n\n              case 27:\n                return _context32.abrupt(\"return\", room);\n\n              case 28:\n              case \"end\":\n                return _context32.stop();\n            }\n          }\n        }, _callee32, this);\n      }));\n    }\n  }]);\n\n  return P2PCommunicationClient;\n}(CommunicationClient);","map":{"version":3,"sources":["../../../../src/transports/clients/P2PCommunicationClient.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAK,MAAZ,MAAwB,oBAAxB;AAEA,OAAO,KAAP,MAAkB,OAAlB;AACA,SACE,UADF,EAEE,KAFF,EAGE,eAHF,EAIE,aAJF,EAKE,uBALF,EAME,uBANF,QAOO,oBAPP;AAQA,SAAS,YAAT,QAA6B,kCAA7B;AACA,SAEE,qBAFF,QAIO,8CAJP;AAKA,SAAS,iBAAT,QAAkC,0CAAlC;AAGA,SAA4B,WAA5B,EAAyC,UAAzC,QAA2D,OAA3D;AACA,SAAS,cAAT,QAA+B,iBAA/B;AACA,SAAS,YAAT,QAA6B,2BAA7B;AAEA,SAAS,WAAT,QAA4B,2BAA5B;AACA,SAAS,MAAT,QAAuB,oBAAvB;AACA,SAAS,mBAAT,QAAoC,uBAApC;AACA,SAAS,cAAT,QAA+B,6BAA/B;AAEA,IAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,wBAAX,CAAf;AAEA,IAAM,mBAAmB,GAAG,CAC1B,+BAD0B,EAE1B,gCAF0B,EAG1B,+BAH0B,CAA5B;;AAMA,IAAM,iBAAiB,GAAG,SAApB,iBAAoB,CAAC,GAAD,EAAkB,GAAlB,EAAiC;AACzD,MAAI,GAAG,GAAG,CAAV;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAAG,CAAC,MAAxB,EAAgC,CAAC,EAAjC,EAAqC;AACnC,IAAA,GAAG,IAAI,GAAG,CAAC,CAAD,CAAH,GAAS,CAAhB;AACD;;AACD,SAAO,IAAI,CAAC,KAAL,CAAW,GAAG,GAAG,GAAjB,CAAP;AACD,CAND;AAQA;;;;AAIG;;;AACH,WAAa,sBAAb;AAAA;;AAAA;;AAgBE,kCACmB,IADnB,EAEE,OAFF,EAGkB,gBAHlB,EAImB,OAJnB,EAKE,WALF,EAMmB,OANnB,EAOmB,MAPnB,EAOkC;AAAA;;AAAA;;AAEhC,8BAAM,OAAN;AARiB,UAAA,IAAA,GAAA,IAAA;AAED,UAAA,gBAAA,GAAA,gBAAA;AACC,UAAA,OAAA,GAAA,OAAA;AAEA,UAAA,OAAA,GAAA,OAAA;AACA,UAAA,MAAA,GAAA,MAAA;AAtBX,UAAA,MAAA,GAAuC,IAAI,cAAJ,EAAvC;AAUS,UAAA,eAAA,GAAwE,IAAI,GAAJ,EAAxE;AAEA,UAAA,YAAA,GAAyB,EAAzB;AACT,UAAA,YAAA,GAAuB,CAAvB;AAaN,IAAA,MAAM,CAAC,GAAP,CAAW,aAAX,EAA0B,gCAA1B;AACA,UAAK,mBAAL,GAA2B,WAAW,CAAC,MAAZ,GAAqB,CAArB,GAAyB,WAAzB,GAAuC,mBAAlE;AALgC;AAMjC;;AA7BH;AAAA;AAAA,WA+Be,iCAAqB;;;;;;;;AAE1B,uBAAM,YAAY,EAAlB;;;;8BAEE,KAAK,I;8BACF,c;;AACE,uBAAM,KAAK,YAAL,EAAN;;;;;AACE,uBAAM,KAAK,cAAL,EAAN;;;;AANT,gBAAA,I;AACJ,kBAAA,E;AACA,kBAAA,I,EAAM,qB;AACN,kBAAA,I;AACA,kBAAA,O;AACA,kBAAA,S;AACA,kBAAA,W;;;AAGF,oBAAI,KAAK,OAAT,EAAkB;AAChB,kBAAA,IAAI,CAAC,IAAL,GAAY,KAAK,OAAjB;AACD;;AACD,oBAAI,KAAK,MAAT,EAAiB;AACf,kBAAA,IAAI,CAAC,MAAL,GAAc,KAAK,MAAnB;AACD;;iDAEM,I;;;;;;;;;AACR;AAjDH;AAAA;AAAA,WAmDe,gCAAuB,OAAvB,EAAiD;;;;;;;+BAEtD,OAAO,CAAC,E;+BAEN,KAAK,I;+BACF,c;;AACE,uBAAM,KAAK,YAAL,EAAN;;;;;AACE,uBAAM,KAAK,cAAL,EAAN;;;;AANT,gBAAA,I;AACJ,kBAAA,E;AACA,kBAAA,I,EAAM,sB;AACN,kBAAA,I;AACA,kBAAA,O;AACA,kBAAA,S;AACA,kBAAA,W;;;AAGF,oBAAI,KAAK,OAAT,EAAkB;AAChB,kBAAA,IAAI,CAAC,IAAL,GAAY,KAAK,OAAjB;AACD;;AACD,oBAAI,KAAK,MAAT,EAAiB;AACf,kBAAA,IAAI,CAAC,MAAL,GAAc,KAAK,MAAnB;AACD;;kDAEM,I;;;;;;;;;AACR;AArEH;AAAA;AAAA,WAuEe,0BAAc;;;;;;;;qBACrB,KAAK,W;;;;;kDACA,KAAK,WAAL,CAAiB,O;;;AAExB,qBAAK,WAAL,GAAmB,IAAI,cAAJ,EAAnB;;;;AAIW,uBAAM,KAAK,OAAL,CAAa,GAAb,CAAiB,UAAU,CAAC,oBAA5B,CAAN;;;AAAP,gBAAA,I;;sBACF,IAAI,IAAI,IAAI,CAAC,MAAL,GAAc,C;;;;;AACxB,qBAAK,WAAL,CAAiB,OAAjB,CAAyB,IAAzB;kDACO,I;;;sBACE,mBAAmB,KAAK,KAAK,mB;;;;;;AAKb,uBAAM,KAAK,OAAL,CAAa,GAAb,CAAiB,UAAU,CAAC,qBAA5B,CAAN;;;AAAnB,gBAAA,gB;;oBACD,gB;;;;;;AAEoB,uBAAM,KAAK,OAAL,CAAa,GAAb,CAAiB,UAAU,CAAC,sBAA5B,CAAN;;;AAAjB,gBAAA,c;AACN,gBAAA,OAAO,CAAC,GAAR,CAAY,iBAAZ,EAA+B,cAA/B;;sBACI,cAAc,CAAC,SAAf,IAA4B,cAAc,CAAC,K;;;;;AAC7C;AACM,gBAAA,K,GAAO,oB,EAAqB;;AAClC,qBAAK,OAAL,CACG,GADH,CACO,UAAU,CAAC,oBADlB,EACwC,KADxC,EAEG,KAFH,CAES,UAAC,KAAD;AAAA,yBAAW,MAAM,CAAC,GAAP,CAAW,KAAX,CAAX;AAAA,iBAFT;AAGA,qBAAK,WAAL,CAAiB,OAAjB,CAAyB,KAAzB;kDACO,K;;;AAGT,qBAAK,OAAL,CAAa,GAAb,CAAiB,UAAU,CAAC,qBAA5B,EAAmD,IAAnD,EAAyD,KAAzD,CAA+D,UAAC,KAAD;AAAA,yBAAW,MAAM,CAAC,GAAP,CAAW,KAAX,CAAX;AAAA,iBAA/D,E,CACA;;;AAIJ,gBAAA,OAAO,CAAC,GAAR,CAAY,kBAAZ;AAEM,gBAAA,U,GAAa,iBAAiB,CAAC,KAAK,OAAL,CAAa,SAAd,EAAyB,KAAK,mBAAL,CAAyB,MAAlD,C;AAChC,gBAAA,M,GAAS,C;;;sBAEN,MAAM,GAAG,KAAK,mBAAL,CAAyB,M;;;;;AACjC,gBAAA,W,GAAc,CAAC,UAAU,GAAG,MAAd,IAAwB,KAAK,mBAAL,CAAyB,M;AAC/D,gBAAA,M,GAAS,KAAK,mBAAL,CAAyB,WAAzB,C;;;AAGb,uBAAM,KAAK,CAAC,GAAN,mBAAqB,MAArB,8BAAN;;;AACA,qBAAK,OAAL,CACG,GADH,CACO,UAAU,CAAC,oBADlB,EACwC,MADxC,EAEG,KAFH,CAES,UAAC,KAAD;AAAA,yBAAW,MAAM,CAAC,GAAP,CAAW,KAAX,CAAX;AAAA,iBAFT;AAIA,qBAAK,WAAL,CAAiB,OAAjB,CAAyB,MAAzB;kDACO,M;;;;;AAEP,gBAAA,MAAM,CAAC,GAAP,6BAA+B,MAA/B;AACA,gBAAA,MAAM;;;;;;;AAIV,qBAAK,WAAL,CAAiB,MAAjB;sBACM,IAAI,KAAJ,+B;;;;;;;;;AACP;AArIH;AAAA;AAAA,WAuIe,sBAAa,MAAb,EAA8C;AAAA,UAAjB,KAAiB,uEAAD,CAAC;;;;;;;;;;AAEhD,uBAAM,KAAK,MAAL,CAAY,OAAlB;;;;AAAP,sCAAkC,SAAlC,CAA4C,MAA5C;;;;;;;;;;AAEA,oBAAI,KAAK,IAAI,EAAT,IAAe,aAAM,OAAN,KAAkB,aAArC,EAAoD;AAClD;AACA,kBAAA,MAAM,CAAC,GAAP;AACA,kBAAA,UAAU,CAAC;AAAA,2BAAW,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACpB,qCAAM,KAAK,YAAL,CAAkB,MAAlB,EAA0B,KAAK,GAAG,CAAlC,CAAN;;AADoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAA,EAAX;AAAA,mBAAD,EAEP,GAFO,CAAV;AAGD,iBAND,MAMO;AACL,kBAAA,MAAM,CAAC,GAAP,gCAAmC,KAAnC;AACD;;;;;;;;;AAEJ;AArJH;AAAA;AAAA,WAuJe,iBAAK;;;;;;;;;AAChB,gBAAA,MAAM,CAAC,GAAP,CAAW,OAAX,EAAoB,iBAApB;;AAEA,uBAAM,MAAM,CAAC,KAAb;;;AAEM,gBAAA,c,GAAiB,MAAM,CAAC,kBAAP,CACrB,EADqB,EAErB,MAAM,CAAC,WAAP,iBAA4B,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,GAAL,KAAa,IAAb,IAAqB,IAAI,EAAzB,CAAX,CAA5B,EAFqB,C;AAIjB,gBAAA,Y,GAAe,MAAM,CAAC,oBAAP,CAA4B,cAA5B,EAA4C,KAAK,OAAL,CAAa,UAAzD,C;AAErB,gBAAA,MAAM,CAAC,GAAP,CAAW,OAAX;;AAEoB,uBAAM,KAAK,cAAL,EAAN;;;AAAd,gBAAA,W;AAEA,gBAAA,M,GAAS,YAAY,CAAC,MAAb,CAAoB;AACjC,kBAAA,OAAO,oBAAa,WAAb,CAD0B;AAEjC,kBAAA,OAAO,EAAE,KAAK;AAFmB,iBAApB,C;;AAKf,qBAAK,eAAL,GAAuB,UACrB,KADqB;AAAA,yBAEJ,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AACjB,gCAAI,KAAK,YAAL,IAAqB,KAAK,YAAL,CAAkB,SAAvC,IAAoD,KAApD,IAA6D,KAAK,CAAC,SAAvE,EAAkF;AAChF,kCAAI,KAAK,YAAL,CAAkB,SAAlB,GAA8B,KAAK,CAAC,SAAxC,EAAmD;AACjD,qCAAK,YAAL,GAAoB,KAApB;AACD;AACF,6BAJD,MAIO;AACL,mCAAK,YAAL,GAAoB,KAApB;AACD;;AAPgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAFI;AAAA,iBAAvB;;AAWA,gBAAA,MAAM,CAAC,SAAP,CAAiB,qBAAqB,CAAC,OAAvC,EAAgD,KAAK,eAArD;AAEA,gBAAA,MAAM,CAAC,SAAP,CAAiB,qBAAqB,CAAC,MAAvC,EAA+C,UAAO,KAAP;AAAA,yBAAgB,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAE7D,gCAAI,KAAK,CAAC,OAAN,CAAc,OAAd,CAAsB,MAAtB,KAAiC,CAArC,EAAwC;AACtC;AACA;AACA,8BAAA,MAAM,GAAG,KAAK,CAAC,OAAN,CAAc,OAAd,CAAsB,CAAtB,CAAT;AACD;;AAN4D;AAQ7D,mCAAM,KAAK,YAAL,CAAkB,KAAK,CAAC,OAAN,CAAc,MAAhC,CAAN;;AAR6D;AAAA,iCAUzD,MAVyD;AAAA;AAAA;AAAA;;AAAA;AAW3D,mCAAM,KAAK,iBAAL,CAAuB,MAAvB,CAAN;;AAX2D;AAAA;AAY3D,mCAAM,KAAK,cAAL,CAAoB,MAApB,EAA4B,KAAK,CAAC,OAAN,CAAc,MAA1C,CAAN;;AAZ2D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAAhB;AAAA,iBAA/C;+BAgBA,M;;AAA6B,uBAAM,KAAK,gBAAL,EAAN;;;;+BAAqC,W;;6BAA3D,G,oBAAI,O,EAAS,O,gBAAwC,I;;;+BAGpD,M;;AACA,uBAAM,KAAK,gBAAL,EAAN;;;;4CACY,KAAK,CAAC,YAAD,C;;AAAkB,uBAAM,KAAK,YAAL,EAAN;;;;;+BAC7B,KAAK,CAAC,KAAK,OAAL,CAAa,SAAd,C;;AAFf,kBAAA,E;AACA,kBAAA,Q;AACA,kBAAA,Q;;;AAHF,oCAAa,KAAb;;;;;;;;;AAMA,gBAAA,OAAO,CAAC,GAAR,CAAY,iBAAZ;;AACA,uBAAM,KAAK,KAAL,EAAN;;;AAAmB;AACnB,gBAAA,OAAO,CAAC,GAAR,CAAY,cAAZ;;sBACI,KAAK,YAAL,IAAqB,KAAK,mBAAL,CAAyB,M;;;;;AAChD,qBAAK,YAAL;AACA,qBAAK,KAAL;;;;sBAGM,IAAI,KAAJ,CAAU,2CAAV,C;;;AAIV,gBAAA,OAAO,CAAC,GAAR,CAAY,iBAAZ;AACA,qBAAK,MAAL,CAAY,OAAZ,CAAoB,MAApB;;;;;;;;;AACD;AA/NH;AAAA;AAAA,WAiOe,gBAAI;;;;;;qBACX,KAAK,MAAL,CAAY,UAAZ,E;;;;;;AACK,uBAAM,KAAK,MAAL,CAAY,OAAlB;;;;AAAP,sCAAkC,IAAlC,GAAyC,KAAzC,CAA+C,UAAC,KAAD;AAAA,yBAAW,MAAM,CAAC,KAAP,CAAa,KAAb,CAAX;AAAA,iBAA/C;;;;AAEF,uBAAM,KAAK,KAAL,EAAN;;;;;;;;;AACD;AAtOH;AAAA;AAAA,WAwOe,iBAAK;;;;;;;AAChB,uBAAM,KAAK,OAAL,CAAa,MAAb,CAAoB,UAAU,CAAC,oBAA/B,EAAqD,KAArD,CAA2D,UAAC,KAAD;AAAA,yBAAW,MAAM,CAAC,GAAP,CAAW,KAAX,CAAX;AAAA,iBAA3D,CAAN;;;;AACA,uBAAM,KAAK,OAAL,CAAa,MAAb,CAAoB,UAAU,CAAC,sBAA/B,EAAuD,KAAvD,CAA6D,UAAC,KAAD;AAAA,yBAAW,MAAM,CAAC,GAAP,CAAW,KAAX,CAAX;AAAA,iBAA7D,CAAN;;;;AACA,uBAAM,KAAK,OAAL,CAAa,MAAb,CAAoB,UAAU,CAAC,oBAA/B,EAAqD,KAArD,CAA2D,UAAC,KAAD;AAAA,yBAAW,MAAM,CAAC,GAAP,CAAW,KAAX,CAAX;AAAA,iBAA3D,CAAN;;;AACA;AACA,qBAAK,WAAL,GAAmB,SAAnB;AACA,qBAAK,MAAL,GAAc,IAAI,cAAJ,EAAd;AACA,qBAAK,YAAL,GAAoB,SAApB;AACA,qBAAK,eAAL,GAAuB,SAAvB;;;;;;;;;AACD;AAjPH;AAAA;AAAA,WAmPe,mCACX,eADW,EAEX,eAFW,EAE+B;;;;;;;;;;qBAEtC,KAAK,eAAL,CAAqB,GAArB,CAAyB,eAAzB,C;;;;;;;;;AAIiB,uBAAM,KAAK,qBAAL,CAA2B,eAA3B,EAA4C,KAAK,OAAL,CAAa,UAAzD,CAAN;;;;AAAb,gBAAA,Q,yBAAA,Q;;AAEF,gBAAA,gB,GAAmB,SAAnB,gBAAmB,CACvB,KADuB;AAAA,yBAEN,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4CACb,KAAK,aAAL,CAAmB,KAAK,CAAC,OAAzB,CADa;;AAAA;AAAA;AAAA;AAAA;;AAAA;AACyB,mCAAM,KAAK,QAAL,CAAc,KAAd,EAAqB,eAArB,CAAN;;AADzB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAIf,mCAAM,KAAK,iBAAL,CAAuB,KAAK,CAAC,OAAN,CAAc,OAAd,CAAsB,MAA7C,CAAN;;AAJe;AAAA;AAKf,mCAAM,KAAK,cAAL,CAAoB,KAAK,CAAC,OAAN,CAAc,OAAd,CAAsB,MAA1C,EAAkD,KAAK,CAAC,OAAN,CAAc,MAAhE,CAAN;;AALe;AAOf,gCAAI;AACF,8BAAA,OAAO,GAAG,MAAM,CAAC,IAAP,CAAY,KAAK,CAAC,OAAN,CAAc,OAAd,CAAsB,OAAlC,EAA2C,KAA3C,CAAV,CADE,CAEF;AACD,6BAHD,CAGE,OAAA,EAAA,EAAM;AACN;AACD;;AAZc,kCAcb,OAAO,IACP,OAAO,CAAC,MAAR,IAAkB,MAAM,CAAC,2BAAP,GAAqC,MAAM,CAAC,yBAfjD;AAAA;AAAA;AAAA;;AAAA;AAAA;AAkBc,mCAAM,uBAAuB,CAAC,OAAD,EAAU,QAAV,CAA7B;;AAlBd;AAkBL,4BAAA,gBAlBK;AAoBX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,4BAAA,eAAe,CAAC,gBAAD,CAAf;AA7BW;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAFM;AAAA,iB;;AAuCzB,qBAAK,eAAL,CAAqB,GAArB,CAAyB,eAAzB,EAA0C,gBAA1C;;AACE,uBAAM,KAAK,MAAL,CAAY,OAAlB;;;gCAA2B,S,CAAU,qBAAqB,CAAC,O,EAAS,gB;;AAEhE,gBAAA,S,GAAY,KAAK,Y;;sBAErB,SAAS,IACT,SAAS,CAAC,SADV,IAEA,IAAI,IAAJ,GAAW,OAAX,KAAuB,SAAS,CAAC,SAAjC,GAA6C,IAAI,EAAJ,GAAS,I;;;;;AAEtD,gBAAA,MAAM,CAAC,GAAP,CAAW,2BAAX,EAAwC,yBAAxC;;AACA,uBAAM,gBAAgB,CAAC,SAAD,CAAtB;;;;;;;AAEA,gBAAA,MAAM,CAAC,GAAP,CAAW,2BAAX,EAAwC,yBAAxC;;;AAGI,gBAAA,e,GAAkB,KAAK,e;;qBACzB,e;;;;;AACF;;AAAE,uBAAM,KAAK,MAAL,CAAY,OAAlB;;;gCAA2B,W,CAAY,qBAAqB,CAAC,O,EAAS,e;;;AAE1E,qBAAK,eAAL,GAAuB,SAAvB;AACA,qBAAK,YAAL,GAAoB,SAApB;;;;;;;;;AACD;AAzTH;AAAA;AAAA,WA2Te,yCAAgC,eAAhC,EAAuD;;;;;;;AAC5D,gBAAA,Q,GAAW,KAAK,eAAL,CAAqB,GAArB,CAAyB,eAAzB,C;;oBACZ,Q;;;;;;;;AAIL;;AAAE,uBAAM,KAAK,MAAL,CAAY,OAAlB;;;gCAA2B,W,CAAY,qBAAqB,CAAC,O,EAAS,Q;;AAExE,qBAAK,eAAL,CAAqB,MAArB,CAA4B,eAA5B;;;;;;;;;AACD;AApUH;AAAA;AAAA,WAsUe,4CAAgC;;;;;;AAC3C;;AAAE,uBAAM,KAAK,MAAL,CAAY,OAAlB;;;gCAA2B,c,CAAe,qBAAqB,CAAC,O;;AAElE,qBAAK,eAAL,CAAqB,KAArB;;;;;;;;;AACD;AA1UH;AAAA;AAAA,WA4Ue,qBACX,OADW,EAEX,IAFW,EAEyC;;;;;;;;;;;AAE/B,uBAAM,KAAK,qBAAL,CAA2B,IAAI,CAAC,SAAhC,EAA2C,KAAK,OAAL,CAAa,UAAxD,CAAN;;;;AAAb,gBAAA,Q,0BAAA,Q;;AAEsB,uBAAM,UAAU,CAAC,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,SAAjB,EAA4B,KAA5B,CAAD,CAAhB;;;AAAxB,gBAAA,a;AACA,gBAAA,S,GAAY,eAAe,CAAC,aAAD,EAAgB,IAAI,CAAC,WAArB,C;;AAElB,uBAAM,KAAK,eAAL,CAAqB,SAArB,CAAN;;;AAAT,gBAAA,M;;AAGN,uBAAM,KAAK,WAAL,CAAiB,MAAjB,CAAN;;;;AAEyB,uBAAM,uBAAuB,CAAC,OAAD,EAAU,QAAV,CAA7B;;;AAAnB,gBAAA,gB;;AAWJ,uBAAM,KAAK,MAAL,CAAY,OAAlB;;;gCAA2B,e,CAAgB,M,EAAQ,gB,EAAkB,K,CAAM,UAAO,KAAP;AAAA,yBAAgB,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kCACvF,KAAK,CAAC,OAAN,KAAkB,aADqE;AAAA;AAAA;AAAA;;AAEzF;AACA,4BAAA,MAAM,CAAC,GAAP,+BAAyC,KAAzC;AAHyF;AAIzF,mCAAM,KAAK,qBAAL,CAA2B,MAA3B,CAAN;;AAJyF;AAAA;AAKvE,mCAAM,KAAK,eAAL,CAAqB,SAArB,CAAN;;AALuE;AAKnF,4BAAA,SALmF;AAAA;AAOvF,mCAAM,KAAK,MAAL,CAAY,OAAlB;;AAPuF;AAAA,4CAQtF,eARsF,CAQtE,SARsE,EAQ3D,gBAR2D,EAStF,KATsF,CAShF,UAAO,MAAP;AAAA,qCAAiB,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AACtB,wCAAA,MAAM,CAAC,GAAP,+BAAyC,MAAzC;;AADsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAAA,EAAjB;AAAA,6BATgF;;AAAA;AAAA;;AAAA;AAazF,4BAAA,MAAM,CAAC,GAAP,iCAA2C,KAA3C;;AAbyF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAAhB;AAAA,iB;;;;;;;;;AAgB9E;AArXH;AAAA;AAAA,WAuXe,wBAAe,MAAf,EAA+B,MAA/B,EAA6C;;;;;;;AACxD;AACM,gBAAA,K,GAAQ,MAAM,CAAC,KAAP,CAAa,GAAb,C;;sBACV,KAAK,CAAC,MAAN,GAAe,CAAf,IAAoB,CAAC,KAAK,CAAC,CAAD,CAAL,CAAS,UAAT,CAAoB,GAApB,C;;;;;sBACjB,IAAI,KAAJ,CAAU,gBAAV,C;;;;AAGQ,uBAAM,KAAK,OAAL,CAAa,GAAb,CAAiB,UAAU,CAAC,oBAA5B,CAAN;;;AAAV,gBAAA,O;AAEA,gBAAA,I,GAAO,OAAO,CAAC,MAAD,C;;AAEpB,oBAAI,IAAI,IAAI,IAAI,CAAC,CAAD,CAAhB,EAAqB;AACnB;AACA,uBAAK,YAAL,CAAkB,IAAlB,CAAuB,IAAI,CAAC,CAAD,CAA3B;AACD;;AAED,gBAAA,OAAO,CAAC,MAAD,CAAP,GAAkB,MAAlB;;AAEA,uBAAM,KAAK,OAAL,CAAa,GAAb,CAAiB,UAAU,CAAC,oBAA5B,EAAkD,OAAlD,CAAN;;;;;;;;;AAID;AA7YH;AAAA;AAAA,WA+Ye,+BAAsB,MAAtB,EAAoC;;;;;;;;AAC/B,uBAAM,KAAK,OAAL,CAAa,GAAb,CAAiB,UAAU,CAAC,oBAA5B,CAAN;;;AAAV,gBAAA,O;AACA,gBAAA,U,GAAa,MAAM,CAAC,OAAP,CAAe,OAAf,EAChB,MADgB,CACT,UAAC,KAAD;AAAA,yBAAW,KAAK,CAAC,CAAD,CAAL,KAAa,MAAxB;AAAA,iBADS,EAEhB,MAFgB,CAGf,UAAC,EAAD,EAAK,EAAL;AAAA,yBAAY,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAM,EAAN,CAAA,sBAAW,EAAE,CAAC,CAAD,CAAb,EAAmB,EAAE,CAAC,CAAD,CAArB,EAAZ;AAAA,iBAHe,EAIf,EAJe,C;;AAQnB,uBAAM,KAAK,OAAL,CAAa,GAAb,CAAiB,UAAU,CAAC,oBAA5B,EAAkD,UAAlD,CAAN;;;AAEA;AACA;AAEA,qBAAK,YAAL,CAAkB,IAAlB,CAAuB,MAAvB;;;;;;;;;AACD;AA/ZH;AAAA;AAAA,WAiae,iCACX,eADW,EAC2D;;;;;;;;AAEtE;;AAAE,uBAAM,KAAK,MAAL,CAAY,OAAlB;;;gCAA2B,S,CAAU,qBAAqB,CAAC,O,EAAS,UAAO,KAAP;AAAA,yBAAgB,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4CAChF,KAAK,aAAL,CAAmB,KAAK,CAAC,OAAzB,CADgF;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAC1C,mCAAM,KAAK,oBAAL,CAA0B,KAAK,CAAC,OAAhC,CAAN;;AAD0C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAElF,4BAAA,MAAM,CAAC,GAAP,+CAAyD,IAAI,CAAC,SAAL,CAAe,KAAf,CAAzD;AAFkF;AAIlF,mCAAM,KAAK,iBAAL,CAAuB,KAAK,CAAC,OAAN,CAAc,OAAd,CAAsB,MAA7C,CAAN;;AAJkF;AAAA;AAKlF,mCAAM,KAAK,cAAL,CAAoB,KAAK,CAAC,OAAN,CAAc,OAAd,CAAsB,MAA1C,EAAkD,KAAK,CAAC,OAAN,CAAc,MAAhE,CAAN;;AALkF;AAO5E,4BAAA,MAP4E,GAOnE,KAAK,CAAC,OAAN,CAAc,OAAd,CAAsB,OAAtB,CAA8B,KAA9B,CAAoC,GAApC,CAPmE;AAQ5E,4BAAA,OAR4E,GAQlE,MAAM,CAAC,IAAP,CAAY,MAAM,CAAC,MAAM,CAAC,MAAP,GAAgB,CAAjB,CAAlB,EAAuC,KAAvC,CARkE;;AAAA,kCAWhF,OAAO,CAAC,MAAR,IACA,MAAM,CAAC,2BAAP,GAAqC,MAAM,CAAC,yBAZoC;AAAA;AAAA;AAAA;;AAAA;AAAA,4CAelC,IAfkC;AAAA;AAgB5E,mCAAM,aAAa,CAAC,OAAD,EAAU,KAAK,OAAL,CAAa,SAAvB,EAAkC,KAAK,OAAL,CAAa,UAA/C,CAAnB;;AAhB4E;AAAA;AAexE,4BAAA,eAfwE,iBAe7B,KAf6B;AAAA,4CAmB9E,eAnB8E;AAAA,4CAmB/D,MAnB+D;AAAA,4CAmB/D,MAAA,CAAA,MAAA,CAAA,EAAA,EACV,eADU,CAnB+D;AAAA;AAqBlE,mCAAM,WAAW,CAAC,eAAe,CAAC,SAAjB,CAAjB;;AArBkE;AAAA;AAAA;AAqB5E,8BAAA,QArB4E;AAAA;AAAA,0DAmB/D,MAnB+D;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAAhB;AAAA,iB;;;;;;;;;AA6BvE;AAjcH;AAAA;AAAA,WAmce,qBAAY,MAAZ,EAA6C;AAAA,UAAjB,KAAiB,uEAAD,CAAC;;;;;;;;;;AAGpC,uBAAM,KAAK,MAAL,CAAY,OAAlB;;;;AAAP,uCAAkC,WAAlC,CAA8C,MAA9C;;;AAAP,gBAAA,I;AACN,gBAAA,MAAM,CAAC,GAAP,oCAAuC,IAAI,CAAC,OAAL,CAAa,MAApD;;sBACI,IAAI,CAAC,OAAL,CAAa,MAAb,IAAuB,CAAvB,IAA4B,IAAI,CAAC,OAAL,CAAa,MAAb,KAAwB,C;;;;;;;;sBAIlD,KAAK,IAAI,G;;;;;AACX;AACA,gBAAA,MAAM,CAAC,GAAP,oCAAuC,KAAvC;mDAEO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAY;AAC7B,kBAAA,UAAU,CAAC;AAAA,2BAAW,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AACpB,8BAAA,OAAO,CAAC,KAAK,WAAL,CAAiB,MAAjB,EAAyB,KAAK,GAAG,CAAjC,CAAD,CAAP;;AADoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAA,EAAX;AAAA,mBAAD,EAEP,OAAO,KAAK,GAAG,EAAR,GAAa,EAAb,GAAkB,CAAzB,CAFO,CAAV,CAD6B,CAGG;AACjC,iBAJM,C;;;sBAMD,IAAI,KAAJ,+BAAiC,KAAjC,a;;;;;;;;;AAGX;AAzdH;AAAA;AAAA,WA2de,6BAAoB,cAApB,EAAqD;;;;;;;;;AAChE,gBAAA,MAAM,CAAC,GAAP;;AACsB,uBAAM,UAAU,CAAC,MAAM,CAAC,IAAP,CAAY,cAAc,CAAC,SAA3B,EAAsC,KAAtC,CAAD,CAAhB;;;AAAhB,gBAAA,a;AACA,gBAAA,S,GAAY,eAAe,CAAC,aAAD,EAAgB,cAAc,CAAC,WAA/B,C,EAEjC;;;AACsB,uBAAM,KAAK,MAAL,CAAY,OAAlB;;;;AAAP,uCAAkC,wBAAlC,CAA2D,SAA3D;;;AAAT,gBAAA,M;;AAEN,uBAAM,KAAK,cAAL,CAAoB,SAApB,EAA+B,MAA/B,CAAN;;;;AAGA,uBAAM,KAAK,WAAL,CAAiB,MAAjB,CAAN;;;sBAIE,OAAO,cAAc,CAAC,OAAtB,KAAkC,W;;;;;;AAC9B,uBAAM,KAAK,YAAL,EAAN;;;;;;;;gCACA,I;;AAAe,uBAAM,KAAK,sBAAL,CAA4B,cAA5B,CAAN;;;;8CAAV,S;;;AAHL,gBAAA,O;;AAK2B,uBAAM,KAAK,wBAAL,CACrC,cAAc,CAAC,SADsB,EAErC,OAFqC,CAAN;;;AAA3B,gBAAA,gB;AAKA,gBAAA,G,GAAM,CAAC,eAAD,EAAkB,SAAlB,EAA6B,gBAA7B,EAA+C,IAA/C,CAAoD,GAApD,C;;AACV,uBAAM,KAAK,MAAL,CAAY,OAAlB;;;gCAA2B,e,CAAgB,M,EAAQ,G,EAAK,K,CAAM,UAAO,KAAP;AAAA,yBAAgB,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kCAC1E,KAAK,CAAC,OAAN,KAAkB,aADwD;AAAA;AAAA;AAAA;;AAE5E;AACA,4BAAA,MAAM,CAAC,GAAP,+BAAyC,KAAzC;AAH4E;AAI5E,mCAAM,KAAK,qBAAL,CAA2B,MAA3B,CAAN;;AAJ4E;AAAA;AAK1D,mCAAM,KAAK,eAAL,CAAqB,SAArB,CAAN;;AAL0D;AAKtE,4BAAA,SALsE;AAAA;AAO1E,mCAAM,KAAK,MAAL,CAAY,OAAlB;;AAP0E;AAAA,4CAO/C,eAP+C,CAO/B,SAP+B,EAOpB,GAPoB,EAOf,KAPe,CAOT,UAAO,MAAP;AAAA,qCAAiB,SAAA,CAAA,OAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAClF,wCAAA,MAAM,CAAC,GAAP,+BAAyC,MAAzC;;AADkF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAAA,EAAjB;AAAA,6BAPS;;AAAA;AAAA;;AAAA;AAW5E,4BAAA,MAAM,CAAC,GAAP,iCAA2C,KAA3C;;AAX4E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAAhB;AAAA,iB;;;;;;;;;AAcjE;AAlgBH;AAAA;AAAA,WAogBS,uBACL,OADK,EACwC;AAE7C,aAAO,OAAO,CAAC,OAAR,CAAgB,IAAhB,KAAyB,iBAAiB,CAAC,IAAlD;AACD;AAxgBH;AAAA;AAAA,WA0gBe,2BAAkB,MAAlB,EAAgC;;;;;;;;;AAC3C;AACM,gBAAA,K,GAAQ,MAAM,CAAC,KAAP,CAAa,GAAb,C;;sBACV,KAAK,CAAC,MAAN,GAAe,CAAf,IAAoB,CAAC,KAAK,CAAC,CAAD,CAAL,CAAS,UAAT,CAAoB,GAApB,C;;;;;sBACjB,IAAI,KAAJ,CAAU,gBAAV,C;;;AAEF,gBAAA,U,GAAa,KAAK,CAAC,KAAN,E;AACb,gBAAA,W,GAAc,KAAK,CAAC,IAAN,CAAW,GAAX,C;AACd,gBAAA,O,GAAU,YAAY,CAAC,OAAb,CAAqB,iCAArB,IACZ,IAAI,WAAJ,CAAgB,KAAK,OAArB,EAA8B,UAAU,CAAC,wBAAzC,CADY,GAEZ,IAAI,WAAJ,CAAgB,KAAK,OAArB,EAA8B,UAAU,CAAC,0BAAzC,C;;AACU,uBAAM,OAAO,CAAC,QAAR,EAAN;;;AAAR,gBAAA,K;AACA,gBAAA,Y,GAAgB,KAAa,CAAC,GAAd,CACpB,UAAO,IAAP;AAAA,yBAA+D,SAAA,CAAA,OAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC5C,mCAAM,UAAU,CAAC,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,SAAjB,EAA4B,KAA5B,CAAD,CAAhB;;AAD4C;AAAA;AACvD,4BAAA,IADuD;;AAAA,kCAEzD,IAAI,KAAK,UAFgD;AAAA;AAAA;AAAA;;AAAA,kCAGvD,IAAI,CAAC,WAAL,KAAqB,WAHkC;AAAA;AAAA;AAAA;;AAIzD,4BAAA,IAAI,CAAC,WAAL,GAAmB,WAAnB;AAJyD;AAKzD,mCAAM,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAN;;AALyD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAA,EAA/D;AAAA,iBADoB,C;;AAWtB,uBAAM,OAAO,CAAC,GAAR,CAAY,YAAZ,CAAN;;;;;;;;;AACD;AAliBH;AAAA;AAAA,WAoiBe,8BACX,OADW,EACqC;;;;;;gCAEzC,OAAO,CAAC,OAAR,CAAgB,O;;gCACG,U;gCAAW,M;;AAAY,uBAAM,KAAK,YAAL,EAAN;;;;8CAAL,I,oCAAgC,K;;AAAxD;;;;;iEADW,U;;;;;;;;;AAGhC;AA1iBH;AAAA;AAAA,WA4iBe,kBACX,KADW,EAEX,eAFW,EAEY;;;;;;gCAEhB,KAAK,CAAC,OAAN,CAAc,OAAd,CAAsB,M;;;AACvB,uBAAM,UAAU,CAAC,MAAM,CAAC,IAAP,CAAY,eAAZ,EAA6B,KAA7B,CAAD,CAAhB;;;;;iEAD8B,U;;;;;;;;;AAGrC;AAnjBH;AAAA;AAAA,WAqjBgB,yBAAgB,SAAhB,EAAiC;;;;;;;;AAC7B,uBAAM,KAAK,OAAL,CAAa,GAAb,CAAiB,UAAU,CAAC,oBAA5B,CAAN;;;AAAV,gBAAA,O;AACF,gBAAA,M,GAAS,OAAO,CAAC,SAAD,C;;oBAEf,M;;;;;AACH,gBAAA,MAAM,CAAC,GAAP,qDAAwD,SAAxD;;AACa,uBAAM,KAAK,qBAAL,CAA2B,SAA3B,CAAN;;;AAAP,gBAAA,I;AACN,gBAAA,MAAM,GAAG,IAAI,CAAC,EAAd;AACA,gBAAA,OAAO,CAAC,SAAD,CAAP,GAAqB,IAAI,CAAC,EAA1B;;AACA,uBAAM,KAAK,OAAL,CAAa,GAAb,CAAiB,UAAU,CAAC,oBAA5B,EAAkD,OAAlD,CAAN;;;AAGF,gBAAA,MAAM,CAAC,GAAP,yCAA4C,MAA5C;mDAEO,M;;;;;;;;;AACR;AApkBH;AAAA;AAAA,WAskBgB,+BAAsB,SAAtB,EAAuC;;;;;;;;;;AACxB,uBAAM,KAAK,MAAL,CAAY,OAAlB;;;;AAAP,uCAAkC,WAAlC;;;AAAd,gBAAA,W;AACN,gBAAA,MAAM,CAAC,GAAP,CAAW,uBAAX,EAAoC,WAApC,EAAiD,SAAjD;AACM,gBAAA,a,GAAgB,WAAW,CAC9B,MADmB,CACZ,UAAC,WAAD;AAAA,yBAA6B,CAAC,OAAI,CAAC,YAAL,CAAkB,IAAlB,CAAuB,UAAC,EAAD;AAAA,2BAAQ,WAAW,CAAC,EAAZ,KAAmB,EAA3B;AAAA,mBAAvB,CAA9B;AAAA,iBADY,EAEnB,MAFmB,CAEZ,UAAC,WAAD;AAAA,yBACN,WAAW,CAAC,OAAZ,CAAoB,IAApB,CAAyB,UAAC,MAAD;AAAA,2BAAoB,MAAM,KAAK,SAA/B;AAAA,mBAAzB,CADM;AAAA,iBAFY,C;;sBASlB,aAAa,CAAC,MAAd,KAAyB,CAAzB,IAA8B,KAAK,YAAL,CAAkB,MAAlB,GAA2B,C;;;;;AAC3D,gBAAA,MAAM,CAAC,GAAP;;AAEsB,uBAAM,KAAK,MAAL,CAAY,OAAlB;;;;AAAP,uCAAkC,wBAAlC,CAA2D,SAA3D;;;AAAT,gBAAA,M;;AACQ,uBAAM,KAAK,MAAL,CAAY,OAAlB;;;;AAAP,uCAAkC,WAAlC,CAA8C,MAA9C;;;AAAP,gBAAA,I;AACA,gBAAA,MAAM,CAAC,GAAP,0EAA6E,IAAI,CAAC,EAAlF;;AACA,uBAAM,KAAK,WAAL,CAAiB,MAAjB,CAAN;;;AACA,gBAAA,MAAM,CAAC,GAAP,uEAA0E,IAAI,CAAC,EAA/E;;;;;AAEA,gBAAA,IAAI,GAAG,aAAa,CAAC,CAAD,CAApB;AACA,gBAAA,MAAM,CAAC,GAAP,uEAA0E,IAAI,CAAC,EAA/E;;;mDAGK,I;;;;;;;;;AACR;AAhmBH;;AAAA;AAAA,EAA4C,mBAA5C","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as sodium from 'libsodium-wrappers';\nimport axios from 'axios';\nimport { getHexHash, toHex, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload } from '../../utils/crypto';\nimport { MatrixClient } from '../../matrix-client/MatrixClient';\nimport { MatrixClientEventType } from '../../matrix-client/models/MatrixClientEvent';\nimport { MatrixMessageType } from '../../matrix-client/models/MatrixMessage';\nimport { PeerManager, StorageKey } from '../..';\nimport { BEACON_VERSION } from '../../constants';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { Logger } from '../../utils/Logger';\nimport { CommunicationClient } from './CommunicationClient';\nimport { ExposedPromise } from '../../utils/exposed-promise';\nconst logger = new Logger('P2PCommunicationClient');\nconst KNOWN_RELAY_SERVERS = [\n    'beacon-node-1.sky.papers.tech',\n    'beacon-node-0.papers.tech:8448',\n    'beacon-node-2.sky.papers.tech'\n];\nconst publicKeyToNumber = (arr, mod) => {\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n        sum += arr[i] + i;\n    }\n    return Math.floor(sum % mod);\n};\n/**\n * @internalapi\n *\n *\n */\nexport class P2PCommunicationClient extends CommunicationClient {\n    constructor(name, keyPair, replicationCount, storage, matrixNodes, iconUrl, appUrl) {\n        super(keyPair);\n        this.name = name;\n        this.replicationCount = replicationCount;\n        this.storage = storage;\n        this.iconUrl = iconUrl;\n        this.appUrl = appUrl;\n        this.client = new ExposedPromise();\n        this.activeListeners = new Map();\n        this.ignoredRooms = [];\n        this.loginCounter = 0;\n        logger.log('constructor', 'P2PCommunicationClient created');\n        this.KNOWN_RELAY_SERVERS = matrixNodes.length > 0 ? matrixNodes : KNOWN_RELAY_SERVERS;\n    }\n    getPairingRequestInfo() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const info = {\n                id: yield generateGUID(),\n                type: 'p2p-pairing-request',\n                name: this.name,\n                version: BEACON_VERSION,\n                publicKey: yield this.getPublicKey(),\n                relayServer: yield this.getRelayServer()\n            };\n            if (this.iconUrl) {\n                info.icon = this.iconUrl;\n            }\n            if (this.appUrl) {\n                info.appUrl = this.appUrl;\n            }\n            return info;\n        });\n    }\n    getPairingResponseInfo(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const info = {\n                id: request.id,\n                type: 'p2p-pairing-response',\n                name: this.name,\n                version: BEACON_VERSION,\n                publicKey: yield this.getPublicKey(),\n                relayServer: yield this.getRelayServer()\n            };\n            if (this.iconUrl) {\n                info.icon = this.iconUrl;\n            }\n            if (this.appUrl) {\n                info.appUrl = this.appUrl;\n            }\n            return info;\n        });\n    }\n    getRelayServer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.relayServer) {\n                return this.relayServer.promise;\n            }\n            else {\n                this.relayServer = new ExposedPromise();\n            }\n            // MIGRATION: If a relay server is set, it's all good and we don't have to do any migration\n            const node = yield this.storage.get(StorageKey.MATRIX_SELECTED_NODE);\n            if (node && node.length > 0) {\n                this.relayServer.resolve(node);\n                return node;\n            }\n            else if (KNOWN_RELAY_SERVERS === this.KNOWN_RELAY_SERVERS) {\n                // Migration start\n                // Only if the array of nodes is the default we do the migration, otherwise we leave it.\n                // If NO relay server is set, we have 3 possibilities:\n                const hasDoneMigration = yield this.storage.get(StorageKey.MULTI_NODE_SETUP_DONE);\n                if (!hasDoneMigration) {\n                    // If this migration has run before, we can skip it.\n                    const preservedState = yield this.storage.get(StorageKey.MATRIX_PRESERVED_STATE);\n                    console.log('PRESERVED STATE', preservedState);\n                    if (preservedState.syncToken || preservedState.rooms) {\n                        // If migration has NOT run and we have a sync state, we know have been previously connected. So we set the old default relayServer as our current node.\n                        const node = 'matrix.papers.tech'; // 2.2.7 Migration: This will default to the old default to avoid peers from losing their relayServer.\n                        this.storage\n                            .set(StorageKey.MATRIX_SELECTED_NODE, node)\n                            .catch((error) => logger.log(error));\n                        this.relayServer.resolve(node);\n                        return node;\n                    }\n                    this.storage.set(StorageKey.MULTI_NODE_SETUP_DONE, true).catch((error) => logger.log(error));\n                    // Migration end\n                }\n            }\n            console.log('GET RELAY SERVER');\n            const startIndex = publicKeyToNumber(this.keyPair.publicKey, this.KNOWN_RELAY_SERVERS.length);\n            let offset = 0;\n            while (offset < this.KNOWN_RELAY_SERVERS.length) {\n                const serverIndex = (startIndex + offset) % this.KNOWN_RELAY_SERVERS.length;\n                const server = this.KNOWN_RELAY_SERVERS[serverIndex];\n                try {\n                    yield axios.get(`https://${server}/_matrix/client/versions`);\n                    this.storage\n                        .set(StorageKey.MATRIX_SELECTED_NODE, server)\n                        .catch((error) => logger.log(error));\n                    this.relayServer.resolve(server);\n                    return server;\n                }\n                catch (relayError) {\n                    logger.log(`Ignoring server \"${server}\", trying another one...`);\n                    offset++;\n                }\n            }\n            this.relayServer.reject(`No matrix server reachable!`);\n            throw new Error(`No matrix server reachable!`);\n        });\n    }\n    tryJoinRooms(roomId, retry = 1) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield (yield this.client.promise).joinRooms(roomId);\n            }\n            catch (error) {\n                if (retry <= 10 && error.errcode === 'M_FORBIDDEN') {\n                    // If we join the room too fast after receiving the invite, the server can accidentally reject our join. This seems to be a problem only when using a federated multi-node setup. Usually waiting for a couple milliseconds solves the issue, but to handle lag, we will keep retrying for 2 seconds.\n                    logger.log(`Retrying to join...`, error);\n                    setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                        yield this.tryJoinRooms(roomId, retry + 1);\n                    }), 200);\n                }\n                else {\n                    logger.log(`Failed to join after ${retry} tries.`, error);\n                }\n            }\n        });\n    }\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('start', 'starting client');\n            yield sodium.ready;\n            const loginRawDigest = sodium.crypto_generichash(32, sodium.from_string(`login:${Math.floor(Date.now() / 1000 / (5 * 60))}`));\n            const rawSignature = sodium.crypto_sign_detached(loginRawDigest, this.keyPair.privateKey);\n            logger.log('start', `connecting to server`);\n            const relayServer = yield this.getRelayServer();\n            const client = MatrixClient.create({\n                baseUrl: `https://${relayServer}`,\n                storage: this.storage\n            });\n            this.initialListener = (event) => __awaiter(this, void 0, void 0, function* () {\n                if (this.initialEvent && this.initialEvent.timestamp && event && event.timestamp) {\n                    if (this.initialEvent.timestamp < event.timestamp) {\n                        this.initialEvent = event;\n                    }\n                }\n                else {\n                    this.initialEvent = event;\n                }\n            });\n            client.subscribe(MatrixClientEventType.MESSAGE, this.initialListener);\n            client.subscribe(MatrixClientEventType.INVITE, (event) => __awaiter(this, void 0, void 0, function* () {\n                let member;\n                if (event.content.members.length === 1) {\n                    // If there is only one member we know it's a new room\n                    // TODO: Use the \"sender\" of the event instead\n                    member = event.content.members[0];\n                }\n                yield this.tryJoinRooms(event.content.roomId);\n                if (member) {\n                    yield this.updateRelayServer(member);\n                    yield this.updatePeerRoom(member, event.content.roomId);\n                }\n            }));\n            logger.log('start', 'login', yield this.getPublicKeyHash(), 'on', relayServer);\n            try {\n                yield client.start({\n                    id: yield this.getPublicKeyHash(),\n                    password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,\n                    deviceId: toHex(this.keyPair.publicKey)\n                });\n            }\n            catch (error) {\n                console.log('ERROR, RETRYING');\n                yield this.reset(); // If we can't log in, let's reset\n                console.log('TRYING AGAIN');\n                if (this.loginCounter <= this.KNOWN_RELAY_SERVERS.length) {\n                    this.loginCounter++;\n                    this.start();\n                    return;\n                }\n                else {\n                    throw new Error('Too many login attempts. Try again later.');\n                }\n            }\n            console.log('client is ready');\n            this.client.resolve(client);\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.client.isResolved()) {\n                yield (yield this.client.promise).stop().catch((error) => logger.error(error));\n            }\n            yield this.reset();\n        });\n    }\n    reset() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.storage.delete(StorageKey.MATRIX_PEER_ROOM_IDS).catch((error) => logger.log(error));\n            yield this.storage.delete(StorageKey.MATRIX_PRESERVED_STATE).catch((error) => logger.log(error));\n            yield this.storage.delete(StorageKey.MATRIX_SELECTED_NODE).catch((error) => logger.log(error));\n            // Instead of resetting everything, maybe we should make sure a new instance is created?\n            this.relayServer = undefined;\n            this.client = new ExposedPromise();\n            this.initialEvent = undefined;\n            this.initialListener = undefined;\n        });\n    }\n    listenForEncryptedMessage(senderPublicKey, messageCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.activeListeners.has(senderPublicKey)) {\n                return;\n            }\n            const { sharedRx } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n            const callbackFunction = (event) => __awaiter(this, void 0, void 0, function* () {\n                if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {\n                    let payload;\n                    yield this.updateRelayServer(event.content.message.sender);\n                    yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n                    try {\n                        payload = Buffer.from(event.content.message.content, 'hex');\n                        // content can be non-hex if it's a connection open request\n                    }\n                    catch (_a) {\n                        /* */\n                    }\n                    if (payload &&\n                        payload.length >= sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {\n                        try {\n                            const decryptedMessage = yield decryptCryptoboxPayload(payload, sharedRx);\n                            // logger.log(\n                            //   'listenForEncryptedMessage',\n                            //   'encrypted message received',\n                            //   decryptedMessage,\n                            //   await new Serializer().deserialize(decryptedMessage)\n                            // )\n                            // console.log('calculated sender ID', await getSenderId(senderPublicKey))\n                            // TODO: Add check for correct decryption key / sender ID\n                            messageCallback(decryptedMessage);\n                        }\n                        catch (decryptionError) {\n                            /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n                        }\n                    }\n                }\n            });\n            this.activeListeners.set(senderPublicKey, callbackFunction);\n            (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, callbackFunction);\n            const lastEvent = this.initialEvent;\n            if (lastEvent &&\n                lastEvent.timestamp &&\n                new Date().getTime() - lastEvent.timestamp < 5 * 60 * 1000) {\n                logger.log('listenForEncryptedMessage', 'Handling previous event');\n                yield callbackFunction(lastEvent);\n            }\n            else {\n                logger.log('listenForEncryptedMessage', 'No previous event found');\n            }\n            const initialListener = this.initialListener;\n            if (initialListener) {\n                ;\n                (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, initialListener);\n            }\n            this.initialListener = undefined;\n            this.initialEvent = undefined;\n        });\n    }\n    unsubscribeFromEncryptedMessage(senderPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const listener = this.activeListeners.get(senderPublicKey);\n            if (!listener) {\n                return;\n            }\n            ;\n            (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, listener);\n            this.activeListeners.delete(senderPublicKey);\n        });\n    }\n    unsubscribeFromEncryptedMessages() {\n        return __awaiter(this, void 0, void 0, function* () {\n            ;\n            (yield this.client.promise).unsubscribeAll(MatrixClientEventType.MESSAGE);\n            this.activeListeners.clear();\n        });\n    }\n    sendMessage(message, peer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { sharedTx } = yield this.createCryptoBoxClient(peer.publicKey, this.keyPair.privateKey);\n            const recipientHash = yield getHexHash(Buffer.from(peer.publicKey, 'hex'));\n            const recipient = recipientString(recipientHash, peer.relayServer);\n            const roomId = yield this.getRelevantRoom(recipient);\n            // Before we send the message, we have to wait for the join to be accepted.\n            yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n            const encryptedMessage = yield encryptCryptoboxPayload(message, sharedTx);\n            (yield this.client.promise).sendTextMessage(roomId, encryptedMessage).catch((error) => __awaiter(this, void 0, void 0, function* () {\n                if (error.errcode === 'M_FORBIDDEN') {\n                    // Room doesn't exist\n                    logger.log(`sendMessage`, `M_FORBIDDEN`, error);\n                    yield this.deleteRoomIdFromRooms(roomId);\n                    const newRoomId = yield this.getRelevantRoom(recipient);\n                    (yield this.client.promise)\n                        .sendTextMessage(newRoomId, encryptedMessage)\n                        .catch((error2) => __awaiter(this, void 0, void 0, function* () {\n                        logger.log(`sendMessage`, `inner error`, error2);\n                    }));\n                }\n                else {\n                    logger.log(`sendMessage`, `not forbidden`, error);\n                }\n            }));\n        });\n    }\n    updatePeerRoom(sender, roomId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n            const split = sender.split(':');\n            if (split.length < 2 || !split[0].startsWith('@')) {\n                throw new Error('Invalid sender');\n            }\n            const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n            const room = roomIds[sender];\n            if (room && room[1]) {\n                // If we have a room already, let's ignore it. We need to do this, otherwise it will be loaded from the matrix cache.\n                this.ignoredRooms.push(room[1]);\n            }\n            roomIds[sender] = roomId;\n            yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n            // TODO: We also need to delete the room from the sync state\n            // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n        });\n    }\n    deleteRoomIdFromRooms(roomId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n            const newRoomIds = Object.entries(roomIds)\n                .filter((entry) => entry[1] !== roomId)\n                .reduce((pv, cv) => (Object.assign(Object.assign({}, pv), { [cv[0]]: cv[1] })), {});\n            yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, newRoomIds);\n            // TODO: We also need to delete the room from the sync state\n            // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n            this.ignoredRooms.push(roomId);\n        });\n    }\n    listenForChannelOpening(messageCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            ;\n            (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, (event) => __awaiter(this, void 0, void 0, function* () {\n                if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {\n                    logger.log(`listenForChannelOpening`, `channel opening`, JSON.stringify(event));\n                    yield this.updateRelayServer(event.content.message.sender);\n                    yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n                    const splits = event.content.message.content.split(':');\n                    const payload = Buffer.from(splits[splits.length - 1], 'hex');\n                    if (payload.length >=\n                        sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {\n                        try {\n                            const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));\n                            messageCallback(Object.assign(Object.assign({}, pairingResponse), { senderId: yield getSenderId(pairingResponse.publicKey) }));\n                        }\n                        catch (decryptionError) {\n                            /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n                        }\n                    }\n                }\n            }));\n        });\n    }\n    waitForJoin(roomId, retry = 0) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Rooms are updated as new events come in. `client.getRoomById` only accesses memory, it does not do any network requests.\n            // TODO: Improve to listen to \"JOIN\" event\n            const room = yield (yield this.client.promise).getRoomById(roomId);\n            logger.log(`waitForJoin`, `Currently ${room.members.length} members, we need at least 2`);\n            if (room.members.length >= 2 || room.members.length === 0) {\n                // 0 means it's an unknown room, we don't need to wait\n                return;\n            }\n            else {\n                if (retry <= 200) {\n                    // On mobile, due to app switching, we potentially have to wait for a long time\n                    logger.log(`Waiting for join... Try: ${retry}`);\n                    return new Promise((resolve) => {\n                        setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                            resolve(this.waitForJoin(roomId, retry + 1));\n                        }), 100 * (retry > 50 ? 10 : 1)); // After the initial 5 seconds, retry only once per second\n                    });\n                }\n                else {\n                    throw new Error(`No one joined after ${retry} tries.`);\n                }\n            }\n        });\n    }\n    sendPairingResponse(pairingRequest) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendPairingResponse`);\n            const recipientHash = yield getHexHash(Buffer.from(pairingRequest.publicKey, 'hex'));\n            const recipient = recipientString(recipientHash, pairingRequest.relayServer);\n            // We force room creation here because if we \"re-pair\", we need to make sure that we don't send it to an old room.\n            const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n            yield this.updatePeerRoom(recipient, roomId);\n            // Before we send the message, we have to wait for the join to be accepted.\n            yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n            // TODO: remove v1 backwards-compatibility\n            const message = typeof pairingRequest.version === 'undefined'\n                ? yield this.getPublicKey() // v1\n                : JSON.stringify(yield this.getPairingResponseInfo(pairingRequest)); // v2\n            const encryptedMessage = yield this.encryptMessageAsymmetric(pairingRequest.publicKey, message);\n            const msg = ['@channel-open', recipient, encryptedMessage].join(':');\n            (yield this.client.promise).sendTextMessage(roomId, msg).catch((error) => __awaiter(this, void 0, void 0, function* () {\n                if (error.errcode === 'M_FORBIDDEN') {\n                    // Room doesn't exist\n                    logger.log(`sendMessage`, `M_FORBIDDEN`, error);\n                    yield this.deleteRoomIdFromRooms(roomId);\n                    const newRoomId = yield this.getRelevantRoom(recipient);\n                    (yield this.client.promise).sendTextMessage(newRoomId, msg).catch((error2) => __awaiter(this, void 0, void 0, function* () {\n                        logger.log(`sendMessage`, `inner error`, error2);\n                    }));\n                }\n                else {\n                    logger.log(`sendMessage`, `not forbidden`, error);\n                }\n            }));\n        });\n    }\n    isTextMessage(content) {\n        return content.message.type === MatrixMessageType.TEXT;\n    }\n    updateRelayServer(sender) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n            const split = sender.split(':');\n            if (split.length < 2 || !split[0].startsWith('@')) {\n                throw new Error('Invalid sender');\n            }\n            const senderHash = split.shift();\n            const relayServer = split.join(':');\n            const manager = localStorage.getItem('beacon:communication-peers-dapp')\n                ? new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_DAPP)\n                : new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_WALLET);\n            const peers = yield manager.getPeers();\n            const promiseArray = peers.map((peer) => __awaiter(this, void 0, void 0, function* () {\n                const hash = `@${yield getHexHash(Buffer.from(peer.publicKey, 'hex'))}`;\n                if (hash === senderHash) {\n                    if (peer.relayServer !== relayServer) {\n                        peer.relayServer = relayServer;\n                        yield manager.addPeer(peer);\n                    }\n                }\n            }));\n            yield Promise.all(promiseArray);\n        });\n    }\n    isChannelOpenMessage(content) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), 'hex'))}`);\n        });\n    }\n    isSender(event, senderPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, 'hex'))}`);\n        });\n    }\n    getRelevantRoom(recipient) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n            let roomId = roomIds[recipient];\n            if (!roomId) {\n                logger.log(`getRelevantRoom`, `No room found for peer ${recipient}, checking joined ones.`);\n                const room = yield this.getRelevantJoinedRoom(recipient);\n                roomId = room.id;\n                roomIds[recipient] = room.id;\n                yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n            }\n            logger.log(`getRelevantRoom`, `Using room ${roomId}`);\n            return roomId;\n        });\n    }\n    getRelevantJoinedRoom(recipient) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const joinedRooms = yield (yield this.client.promise).joinedRooms;\n            logger.log('checking joined rooms', joinedRooms, recipient);\n            const relevantRooms = joinedRooms\n                .filter((roomElement) => !this.ignoredRooms.some((id) => roomElement.id === id))\n                .filter((roomElement) => roomElement.members.some((member) => member === recipient));\n            let room;\n            // We always create a new room if one has been ignored. This is because if we ignore one, we know the server state changed.\n            // So we cannot trust the current sync state. This can be removed once we have a method to properly clear and refresh the sync state.\n            if (relevantRooms.length === 0 || this.ignoredRooms.length > 0) {\n                logger.log(`getRelevantJoinedRoom`, `no relevant rooms found, creating new one`);\n                const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n                room = yield (yield this.client.promise).getRoomById(roomId);\n                logger.log(`getRelevantJoinedRoom`, `waiting for other party to join room: ${room.id}`);\n                yield this.waitForJoin(roomId);\n                logger.log(`getRelevantJoinedRoom`, `new room created and peer invited: ${room.id}`);\n            }\n            else {\n                room = relevantRooms[0];\n                logger.log(`getRelevantJoinedRoom`, `channel already open, reusing room ${room.id}`);\n            }\n            return room;\n        });\n    }\n}\n//# sourceMappingURL=P2PCommunicationClient.js.map"]},"metadata":{},"sourceType":"module"}