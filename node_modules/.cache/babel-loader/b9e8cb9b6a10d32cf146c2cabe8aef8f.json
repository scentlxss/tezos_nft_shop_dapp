{"ast":null,"code":"import { MichelsonMap, Schema } from '@taquito/michelson-encoder';\nimport { bytes2Char, Tzip16ContractAbstraction, MetadataProvider, DEFAULT_HANDLERS } from '@taquito/tzip16';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nvar TokenMetadataNotFound =\n/** @class */\nfunction () {\n  function TokenMetadataNotFound(address) {\n    this.address = address;\n    this.name = 'TokenMetadataNotFound';\n    this.message = \"No token metadata was found for the contract: \" + address;\n  }\n\n  return TokenMetadataNotFound;\n}();\n\nvar TokenIdNotFound =\n/** @class */\nfunction () {\n  function TokenIdNotFound(tokenId) {\n    this.tokenId = tokenId;\n    this.name = 'TokenIdNotFound';\n    this.message = \"Could not find token metadata for the token ID: \" + tokenId;\n  }\n\n  return TokenIdNotFound;\n}();\n\nvar InvalidTokenMetadata =\n/** @class */\nfunction () {\n  function InvalidTokenMetadata() {\n    this.name = 'InvalidTokenMetadata';\n    this.message = 'Non-compliance with the TZIP-012 standard. The required property `decimals` is missing.';\n  }\n\n  return InvalidTokenMetadata;\n}();\n\nvar tokenMetadataBigMapType = {\n  prim: 'big_map',\n  args: [{\n    prim: 'nat'\n  }, {\n    prim: 'pair',\n    args: [{\n      prim: 'nat',\n      annots: ['%token_id']\n    }, {\n      prim: \"map\",\n      args: [{\n        prim: 'string'\n      }, {\n        prim: 'bytes'\n      }],\n      annots: ['%token_info']\n    }]\n  }],\n  annots: ['%token_metadata']\n};\n\nvar Tzip12ContractAbstraction =\n/** @class */\nfunction () {\n  function Tzip12ContractAbstraction(contractAbstraction, context) {\n    this.contractAbstraction = contractAbstraction;\n    this.context = context;\n    this._tzip16ContractAbstraction = new Tzip16ContractAbstraction(this.contractAbstraction, this.context);\n  }\n  /**\r\n   * @description Fetches the contract metadata (according to the Tzip-016 standard)\r\n   * @returns An object containing the metadata, the uri, an optional integrity check result and an optional sha256 hash\r\n   * or `Undefined` if the contract has no metadata (non-compliant with Tzip-016)\r\n   */\n\n\n  Tzip12ContractAbstraction.prototype.getContractMetadata = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var contractMetadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this._tzip16ContractAbstraction.getMetadata()];\n\n          case 1:\n            contractMetadata = _a.sent();\n            return [2\n            /*return*/\n            , contractMetadata.metadata];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * @description The Tzip-016 \"interfaces\" field MUST be present in the contract metadata. It should contain \"TZIP-012[version-info]\"\r\n   * @returns True if \"interfaces\" field is present and contains \"TZIP-012\", false otherwise\r\n   */\n\n\n  Tzip12ContractAbstraction.prototype.isTzip12Compliant = function () {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var isCompliant, metadata, tzip12Interface;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            isCompliant = false;\n            return [4\n            /*yield*/\n            , this.getContractMetadata()];\n\n          case 1:\n            metadata = _b.sent();\n\n            if (metadata) {\n              tzip12Interface = (_a = metadata.interfaces) === null || _a === void 0 ? void 0 : _a.filter(function (x) {\n                return x.substring(0, 8) === \"TZIP-012\";\n              });\n              isCompliant = tzip12Interface && tzip12Interface.length !== 0 ? true : false;\n            }\n\n            return [2\n            /*return*/\n            , isCompliant];\n        }\n      });\n    });\n  };\n  /**\r\n   * @description Fetches the token metadata for a specified token ID.\r\n   * The function first tries to find a `token_metadata` view in the contract metadata and to execute it with the token ID.\r\n   * If there is no view, the function tries to find a `token_metadata` bigmap in the top-level pairs of the storage.\r\n   * @param tokenId The ID of the token for which we want to retrieve token metadata\r\n   * @returns An object of type `TokenMetadata`\r\n   */\n\n\n  Tzip12ContractAbstraction.prototype.getTokenMetadata = function (tokenId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tokenMetadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.retrieveTokenMetadataFromView(tokenId)];\n\n          case 1:\n            tokenMetadata = _a.sent();\n            return [2\n            /*return*/\n            , !tokenMetadata ? this.retrieveTokenMetadataFromBigMap(tokenId) : tokenMetadata];\n        }\n      });\n    });\n  };\n\n  Tzip12ContractAbstraction.prototype.retrieveTokenMetadataFromView = function (tokenId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var views;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getContractMetadata()];\n\n          case 1:\n            if (!_a.sent()) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this._tzip16ContractAbstraction.metadataViews()];\n\n          case 2:\n            views = _a.sent();\n\n            if (views && this.hasTokenMetadataView(views)) {\n              return [2\n              /*return*/\n              , this.executeTokenMetadataView(views['token_metadata'](), tokenId)];\n            }\n\n            _a.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Tzip12ContractAbstraction.prototype.hasTokenMetadataView = function (views) {\n    var e_1, _a;\n\n    try {\n      for (var _b = __values(Object.keys(views)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var view = _c.value;\n\n        if (view === 'token_metadata') {\n          return true;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return false;\n  };\n\n  Tzip12ContractAbstraction.prototype.executeTokenMetadataView = function (tokenMetadataView, tokenId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tokenMetadata, tokenMap, metadataFromUri;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , tokenMetadataView.executeView(tokenId)];\n\n          case 1:\n            tokenMetadata = _a.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            _a.sent();\n\n            throw new TokenIdNotFound(tokenId);\n\n          case 3:\n            tokenMap = Object.values(tokenMetadata)[1];\n\n            if (!MichelsonMap.isMichelsonMap(tokenMap)) {\n              throw new TokenMetadataNotFound(this.contractAbstraction.address);\n            }\n\n            return [4\n            /*yield*/\n            , this.fetchTokenMetadataFromUri(tokenMap)];\n\n          case 4:\n            metadataFromUri = _a.sent();\n            return [2\n            /*return*/\n            , this.formatMetadataToken(tokenId, tokenMap, metadataFromUri)];\n        }\n      });\n    });\n  };\n\n  Tzip12ContractAbstraction.prototype.fetchTokenMetadataFromUri = function (tokenMetadata) {\n    return __awaiter(this, void 0, void 0, function () {\n      var uri, metadataFromUri, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            uri = tokenMetadata.get(\"\");\n            if (!uri) return [3\n            /*break*/\n            , 4];\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.context.metadataProvider.provideMetadata(this.contractAbstraction, bytes2Char(uri), this.context)];\n\n          case 2:\n            metadataFromUri = _a.sent();\n            return [2\n            /*return*/\n            , metadataFromUri.metadata];\n\n          case 3:\n            e_2 = _a.sent();\n\n            if (e_2.name === 'InvalidUri') {\n              console.warn(\"The URI \" + bytes2Char(uri) + \" is present in the token metadata, but is invalid.\");\n            } else {\n              throw e_2;\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Tzip12ContractAbstraction.prototype.formatMetadataToken = function (tokenId, metadataTokenMap, metadataFromUri) {\n    var e_3, _a, _b, _c, _d;\n\n    var tokenMetadataDecoded = {\n      'token_id': tokenId\n    };\n\n    try {\n      for (var _e = __values(metadataTokenMap.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {\n        var keyTokenMetadata = _f.value;\n\n        if (keyTokenMetadata === 'decimals') {\n          Object.assign(tokenMetadataDecoded, (_b = {}, _b[keyTokenMetadata] = Number(bytes2Char(metadataTokenMap.get(keyTokenMetadata))), _b));\n        } else if (!(keyTokenMetadata === '')) {\n          Object.assign(tokenMetadataDecoded, (_c = {}, _c[keyTokenMetadata] = bytes2Char(metadataTokenMap.get(keyTokenMetadata)), _c));\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    } // if an URI is present, add the fetched properties to the object\n    // if a property is in the URI and the map, prevalence is accorded to value from the URI\n\n\n    if (metadataFromUri) {\n      for (var property in metadataFromUri) {\n        Object.assign(tokenMetadataDecoded, (_d = {}, _d[property] = metadataFromUri[property], _d));\n      }\n    }\n\n    if (!('decimals' in tokenMetadataDecoded)) {\n      throw new InvalidTokenMetadata();\n    }\n\n    return tokenMetadataDecoded;\n  };\n\n  Tzip12ContractAbstraction.prototype.retrieveTokenMetadataFromBigMap = function (tokenId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var bigmapTokenMetadataId, pairNatMap, michelsonMap, metadataFromUri;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            bigmapTokenMetadataId = this.findTokenMetadataBigMap();\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.context.contract.getBigMapKeyByID(bigmapTokenMetadataId['int'].toString(), tokenId.toString(), new Schema(tokenMetadataBigMapType))];\n\n          case 2:\n            pairNatMap = _a.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            _a.sent();\n\n            throw new TokenIdNotFound(tokenId);\n\n          case 4:\n            michelsonMap = pairNatMap['token_info'];\n\n            if (!MichelsonMap.isMichelsonMap(michelsonMap)) {\n              throw new TokenIdNotFound(tokenId);\n            }\n\n            return [4\n            /*yield*/\n            , this.fetchTokenMetadataFromUri(michelsonMap)];\n\n          case 5:\n            metadataFromUri = _a.sent();\n            return [2\n            /*return*/\n            , this.formatMetadataToken(tokenId, michelsonMap, metadataFromUri)];\n        }\n      });\n    });\n  };\n\n  Tzip12ContractAbstraction.prototype.findTokenMetadataBigMap = function () {\n    var tokenMetadataBigMapId = this.contractAbstraction.schema.FindFirstInTopLevelPair(this.contractAbstraction.script.storage, tokenMetadataBigMapType);\n\n    if (!tokenMetadataBigMapId) {\n      throw new TokenMetadataNotFound(this.contractAbstraction.address);\n    }\n\n    return tokenMetadataBigMapId;\n  };\n\n  return Tzip12ContractAbstraction;\n}();\n\nvar ABSTRACTION_KEY = Symbol(\"Tzip12ContractAbstractionObjectKey\");\n\nfunction tzip12(abs, context) {\n  return Object.assign(abs, {\n    // namespace tzip12\n    tzip12: function () {\n      if (!this[ABSTRACTION_KEY]) {\n        this[ABSTRACTION_KEY] = new Tzip12ContractAbstraction(this, context);\n      }\n\n      return this[ABSTRACTION_KEY];\n    }\n  });\n} // The same default metadataProvider is used for tzip16 and tzip12\n\n\nvar Tzip12Module =\n/** @class */\nfunction () {\n  function Tzip12Module(metadataProvider) {\n    this._metadataProvider = metadataProvider ? metadataProvider : new MetadataProvider(DEFAULT_HANDLERS);\n  }\n\n  Tzip12Module.prototype.configureContext = function (context) {\n    Object.assign(context, {\n      metadataProvider: this._metadataProvider\n    });\n  };\n\n  return Tzip12Module;\n}(); // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n\n/* tslint:disable */\n\n\nvar VERSION = {\n  \"commitHash\": \"33283ebb64d801dcbb0926ad199d024ad7189861\",\n  \"version\": \"10.1.0\"\n};\n/* tslint:enable */\n\nexport { InvalidTokenMetadata, TokenIdNotFound, TokenMetadataNotFound, Tzip12ContractAbstraction, Tzip12Module, VERSION, tzip12 };","map":{"version":3,"sources":["../src/tzip12-errors.ts","../src/tzip12-contract-abstraction.ts","../src/composer.ts","../src/tzip12-extension.ts","../src/version.ts"],"names":[],"mappings":"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","sourcesContent":["export class TokenMetadataNotFound implements Error {\n    name: string = 'TokenMetadataNotFound';\n    message: string;\n\n    constructor(public address: string) {\n        this.message = `No token metadata was found for the contract: ${address}`;\n    }\n}\n\nexport class TokenIdNotFound implements Error {\n    name: string = 'TokenIdNotFound';\n    message: string;\n\n    constructor(public tokenId: number) {\n        this.message = `Could not find token metadata for the token ID: ${tokenId}`;\n    }\n}\n\nexport class InvalidTokenMetadata implements Error {\n    name = 'InvalidTokenMetadata';\n    message = 'Non-compliance with the TZIP-012 standard. The required property `decimals` is missing.';\n}","import { MichelsonMap, Schema } from '@taquito/michelson-encoder';\nimport { ContractAbstraction, ContractProvider, Wallet } from '@taquito/taquito';\nimport { Tzip16ContractAbstraction, MetadataContext, View, bytes2Char, MetadataInterface } from '@taquito/tzip16'\nimport { InvalidTokenMetadata, TokenIdNotFound, TokenMetadataNotFound } from './tzip12-errors';\n\nconst tokenMetadataBigMapType = {\n    prim: 'big_map',\n    args: [\n        { prim: 'nat' }, \n        { prim: 'pair', args: [\n            { prim: 'nat' , annots: ['%token_id']}, \n            { prim: \"map\", args: [{ prim: 'string' }, { prim: 'bytes' }], annots: ['%token_info'] }] }],\n    annots: ['%token_metadata']\n};\n\ntype BigMapId = { int: string };\n\nexport interface TokenMetadata {\n    token_id: number,\n    decimals: number\n    name?: string,\n    symbol?: string,\n}\n\nexport class Tzip12ContractAbstraction {\n    private _tzip16ContractAbstraction: Tzip16ContractAbstraction;\n\n    constructor(\n        private contractAbstraction: ContractAbstraction<ContractProvider | Wallet>,\n        private context: MetadataContext\n    ) {\n        this._tzip16ContractAbstraction = new Tzip16ContractAbstraction(this.contractAbstraction, this.context)\n    }\n\n    /**\n     * @description Fetches the contract metadata (according to the Tzip-016 standard)\n     * @returns An object containing the metadata, the uri, an optional integrity check result and an optional sha256 hash \n     * or `Undefined` if the contract has no metadata (non-compliant with Tzip-016)\n     */\n    private async getContractMetadata() {\n        try {\n            const contractMetadata = await this._tzip16ContractAbstraction.getMetadata();\n            return contractMetadata.metadata;\n        } catch (err) {\n            // The contract is not compliant with Tzip-016. There is no contract metadata.\n        }\n    }\n\n    /**\n     * @description The Tzip-016 \"interfaces\" field MUST be present in the contract metadata. It should contain \"TZIP-012[version-info]\"\n     * @returns True if \"interfaces\" field is present and contains \"TZIP-012\", false otherwise\n     */\n    async isTzip12Compliant() {\n        let isCompliant = false;\n        const metadata = await this.getContractMetadata();\n        if (metadata) {\n            const tzip12Interface = metadata.interfaces?.filter((x) => {\n                return x.substring(0, 8) === \"TZIP-012\";\n            });\n            isCompliant = (tzip12Interface && tzip12Interface.length !== 0) ? true : false;\n        }\n        return isCompliant;\n    }\n\n    /**\n     * @description Fetches the token metadata for a specified token ID.\n     * The function first tries to find a `token_metadata` view in the contract metadata and to execute it with the token ID.\n     * If there is no view, the function tries to find a `token_metadata` bigmap in the top-level pairs of the storage.\n     * @param tokenId The ID of the token for which we want to retrieve token metadata\n     * @returns An object of type `TokenMetadata`\n     */\n    async getTokenMetadata(tokenId: number) {\n        const tokenMetadata = await this.retrieveTokenMetadataFromView(tokenId);\n        return (!tokenMetadata) ? this.retrieveTokenMetadataFromBigMap(tokenId) : tokenMetadata;\n    }\n\n    private async retrieveTokenMetadataFromView(tokenId: number) {\n        if (await this.getContractMetadata()) {\n            const views = await this._tzip16ContractAbstraction.metadataViews();\n            if (views && this.hasTokenMetadataView(views)) {\n                return this.executeTokenMetadataView(views['token_metadata'](), tokenId);\n            }\n        }\n    }\n\n    private hasTokenMetadataView(views: {}) {\n        for (let view of Object.keys(views)) {\n            if (view === 'token_metadata') {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private async executeTokenMetadataView(tokenMetadataView: View, tokenId: number): Promise<TokenMetadata> {\n        let tokenMetadata;\n        try {\n            tokenMetadata = await tokenMetadataView.executeView(tokenId);\n        } catch (err) {\n            throw new TokenIdNotFound(tokenId);\n        }\n        const tokenMap = Object.values(tokenMetadata)[1];\n        if (!MichelsonMap.isMichelsonMap(tokenMap)) {\n            throw new TokenMetadataNotFound(this.contractAbstraction.address);\n        }\n        const metadataFromUri = await this.fetchTokenMetadataFromUri(tokenMap as MichelsonMap<string, string>);\n        return this.formatMetadataToken(tokenId, (tokenMap as MichelsonMap<string, string>), metadataFromUri);\n    }\n\n    private async fetchTokenMetadataFromUri(tokenMetadata: MichelsonMap<string, string>) {\n        const uri = tokenMetadata.get(\"\");\n        if (uri) {\n            try {\n                const metadataFromUri = await this.context.metadataProvider.provideMetadata(\n                    this.contractAbstraction,\n                    bytes2Char(uri),\n                    this.context\n                );\n                return metadataFromUri.metadata;\n            } catch (e) {\n                if (e.name === 'InvalidUri') {\n                    console.warn(`The URI ${bytes2Char(uri)} is present in the token metadata, but is invalid.`);\n                } else {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    private formatMetadataToken(tokenId: number, metadataTokenMap: MichelsonMap<string, string>, metadataFromUri?: any): TokenMetadata {\n        const tokenMetadataDecoded = {\n            'token_id': tokenId\n        };\n        for (let keyTokenMetadata of metadataTokenMap.keys()) {\n            if (keyTokenMetadata === 'decimals') {\n                Object.assign(tokenMetadataDecoded, { [keyTokenMetadata]: Number(bytes2Char(metadataTokenMap.get(keyTokenMetadata)!)) });\n            }\n            else if (!(keyTokenMetadata === '')) {\n                Object.assign(tokenMetadataDecoded, { [keyTokenMetadata]: bytes2Char(metadataTokenMap.get(keyTokenMetadata)!) });\n            }\n        }\n        // if an URI is present, add the fetched properties to the object\n        // if a property is in the URI and the map, prevalence is accorded to value from the URI\n        if (metadataFromUri) {\n            for(let property in metadataFromUri) {\n                Object.assign(tokenMetadataDecoded, {[property]: metadataFromUri[property]})\n            }\n        }\n        if(!('decimals' in tokenMetadataDecoded)) {\n            throw new InvalidTokenMetadata();\n        } \n        return tokenMetadataDecoded;\n    }\n\n    private async retrieveTokenMetadataFromBigMap(tokenId: number) {\n        const bigmapTokenMetadataId = this.findTokenMetadataBigMap();\n        let pairNatMap;\n        try {\n            pairNatMap = await this.context.contract.getBigMapKeyByID<any>(\n                bigmapTokenMetadataId['int'].toString(),\n                tokenId.toString(),\n                new Schema(tokenMetadataBigMapType)\n            );\n        } catch (err) {\n            throw new TokenIdNotFound(tokenId);\n        }\n\n        const michelsonMap = pairNatMap['token_info'];\n        if (!MichelsonMap.isMichelsonMap(michelsonMap)) {\n            throw new TokenIdNotFound(tokenId);\n        }\n        const metadataFromUri = await this.fetchTokenMetadataFromUri(michelsonMap as MichelsonMap<string, string>);\n        return this.formatMetadataToken(tokenId, michelsonMap as MichelsonMap<string, string>, metadataFromUri)\n    }\n\n    private findTokenMetadataBigMap(): BigMapId {\n        const tokenMetadataBigMapId = this.contractAbstraction.schema.FindFirstInTopLevelPair<BigMapId>(\n            this.contractAbstraction.script.storage,\n            tokenMetadataBigMapType\n        );\n        if (!tokenMetadataBigMapId) {\n            throw new TokenMetadataNotFound(this.contractAbstraction.address);\n        }\n        return tokenMetadataBigMapId;\n    }\n\n\n}\n","import { Context, ContractAbstraction, ContractProvider, Wallet } from \"@taquito/taquito\";\nimport { Tzip12ContractAbstraction } from './tzip12-contract-abstraction'\nimport { MetadataContext } from \"@taquito/tzip16\"\n\nconst ABSTRACTION_KEY = Symbol(\"Tzip12ContractAbstractionObjectKey\");\n\nexport function tzip12<T extends ContractAbstraction<ContractProvider | Wallet>>(abs: T, context: Context) {\n    return Object.assign(abs, {\n        // namespace tzip12\n        tzip12 (this: ContractAbstraction<ContractProvider | Wallet> & { [ABSTRACTION_KEY]?: Tzip12ContractAbstraction}) {\n            if (!this[ABSTRACTION_KEY]) {\n                this[ABSTRACTION_KEY] = new Tzip12ContractAbstraction(this, context as MetadataContext);\n            }\n            \n            return this[ABSTRACTION_KEY]!\n        }\n    })\n}","import { Context, Extension } from \"@taquito/taquito\";\nimport { DEFAULT_HANDLERS, MetadataProviderInterface, MetadataProvider } from '@taquito/tzip16'\n\n// The same default metadataProvider is used for tzip16 and tzip12\nexport class Tzip12Module implements Extension {\n    private _metadataProvider: MetadataProviderInterface;\n\n    constructor(metadataProvider?: MetadataProviderInterface) {\n        this._metadataProvider = metadataProvider ? metadataProvider : new MetadataProvider(DEFAULT_HANDLERS);\n    }\n\n    configureContext(context: Context) {\n        Object.assign(context, { metadataProvider: this._metadataProvider });\n    }\n}","\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n/* tslint:disable */\nexport const VERSION = {\n    \"commitHash\": \"33283ebb64d801dcbb0926ad199d024ad7189861\",\n    \"version\": \"10.1.0\"\n};\n/* tslint:enable */\n"]},"metadata":{},"sourceType":"module"}