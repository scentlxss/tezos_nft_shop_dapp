{"ast":null,"code":"import _regeneratorRuntime from \"/opt/tezos/nft-shop-example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/opt/tezos/nft-shop-example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/opt/tezos/nft-shop-example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger } from '../utils/Logger';\nimport { TransportType, TransportStatus } from '..';\nvar logger = new Logger('Transport');\n/**\n * @internalapi\n *\n *\n */\n\nexport var Transport = /*#__PURE__*/function () {\n  function Transport(name, client, peerManager) {\n    _classCallCheck(this, Transport);\n\n    /**\n     * The type of the transport\n     */\n    this.type = TransportType.POST_MESSAGE;\n    /**\n     * The status of the transport\n     */\n\n    this._isConnected = TransportStatus.NOT_CONNECTED;\n    /**\n     * The listeners that will be notified when new messages are coming in\n     */\n\n    this.listeners = [];\n    this.name = name;\n    this.client = client;\n    this.peerManager = peerManager;\n  }\n  /**\n   * Return the status of the connection\n   */\n\n\n  _createClass(Transport, [{\n    key: \"connectionStatus\",\n    get: function get() {\n      return this._isConnected;\n    }\n    /**\n     * Returns a promise that resolves to true if the transport is available, false if it is not\n     */\n\n  }, {\n    key: \"connect\",\n    value:\n    /**\n     * Connect the transport\n     */\n    function connect() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger.log('connect');\n                this._isConnected = TransportStatus.CONNECTED;\n                return _context.abrupt(\"return\");\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Disconnect the transport\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                logger.log('disconnect');\n                this._isConnected = TransportStatus.NOT_CONNECTED;\n                return _context2.abrupt(\"return\");\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Send a message through the transport\n     *\n     * @param message The message to send\n     * @param recipient The recipient of the message\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(message, peer) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this = this;\n\n        var knownPeers, promises;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!peer) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this.client.sendMessage(message, peer));\n\n              case 4:\n                _context3.next = 6;\n                return this.getPeers();\n\n              case 6:\n                knownPeers = _context3.sent;\n                // A broadcast request has to be sent everywhere.\n                promises = knownPeers.map(function (peerEl) {\n                  return _this.client.sendMessage(message, peerEl);\n                });\n                _context3.next = 10;\n                return Promise.all(promises);\n\n              case 10:\n                return _context3.abrupt(\"return\", _context3.sent[0]);\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Add a listener to be called when a new message is received\n     *\n     * @param listener The listener that will be registered\n     */\n\n  }, {\n    key: \"addListener\",\n    value: function addListener(listener) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                logger.debug('addListener', listener);\n                this.listeners.push(listener);\n                return _context4.abrupt(\"return\");\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Remove a listener\n     *\n     * @param listener\n     */\n\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(listener) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                logger.log('removeListener');\n                this.listeners = this.listeners.filter(function (element) {\n                  return element !== listener;\n                });\n                return _context5.abrupt(\"return\");\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n  }, {\n    key: \"getPeers\",\n    value: function getPeers() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this.peerManager.getPeers());\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"addPeer\",\n    value: function addPeer(newPeer) {\n      var _sendPairingResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                logger.log('addPeer', 'adding peer', newPeer);\n                _context7.next = 3;\n                return this.peerManager.addPeer(newPeer);\n\n              case 3:\n                _context7.next = 5;\n                return this.listen(newPeer.publicKey);\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n  }, {\n    key: \"removePeer\",\n    value: function removePeer(peerToBeRemoved) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                logger.log('removePeer', 'removing peer', peerToBeRemoved);\n                _context8.next = 3;\n                return this.peerManager.removePeer(peerToBeRemoved.publicKey);\n\n              case 3:\n                if (!this.client) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                _context8.next = 6;\n                return this.client.unsubscribeFromEncryptedMessage(peerToBeRemoved.publicKey);\n\n              case 6:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n  }, {\n    key: \"removeAllPeers\",\n    value: function removeAllPeers() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                logger.log('removeAllPeers');\n                _context9.next = 3;\n                return this.peerManager.removeAllPeers();\n\n              case 3:\n                if (!this.client) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                _context9.next = 6;\n                return this.client.unsubscribeFromEncryptedMessages();\n\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }\n    /**\n     * Notify the listeners when a new message comes in\n     *\n     * @param message Message\n     * @param connectionInfo Context info about the connection\n     */\n\n  }, {\n    key: \"notifyListeners\",\n    value: function notifyListeners(message, connectionInfo) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (this.listeners.length === 0) {\n                  logger.warn('notifyListeners', '0 listeners notified!', this);\n                } else {\n                  logger.log('notifyListeners', \"Notifying \".concat(this.listeners.length, \" listeners\"), this);\n                }\n\n                this.listeners.forEach(function (listener) {\n                  listener(message, connectionInfo);\n                });\n                return _context10.abrupt(\"return\");\n\n              case 3:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n  }], [{\n    key: \"isAvailable\",\n    value: function isAvailable() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                return _context11.abrupt(\"return\", Promise.resolve(false));\n\n              case 1:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11);\n      }));\n    }\n  }]);\n\n  return Transport;\n}();","map":{"version":3,"sources":["../../../src/transports/Transport.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAS,MAAT,QAAuB,iBAAvB;AAEA,SAAS,aAAT,EAAwB,eAAxB,QAA2F,IAA3F;AAKA,IAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,WAAX,CAAf;AAEA;;;;AAIG;;AACH,WAAsB,SAAtB;AAgDE,qBAAY,IAAZ,EAA0B,MAA1B,EAAqC,WAArC,EAAgE;AAAA;;AAvChE;;AAEG;AACa,SAAA,IAAA,GAAsB,aAAa,CAAC,YAApC;AAOhB;;AAEG;;AACO,SAAA,YAAA,GAAgC,eAAe,CAAC,aAAhD;AAcV;;AAEG;;AACK,SAAA,SAAA,GAA+E,EAA/E;AAUN,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,MAAL,GAAc,MAAd;AACA,SAAK,WAAL,GAAmB,WAAnB;AACD;AAXD;;AAEG;;;AA3CL;AAAA;AAAA,SA4CE,eAA2B;AACzB,aAAO,KAAK,YAAZ;AACD;AAQD;;AAEG;;AAxDL;AAAA;AAAA;AA6DE;;AAEG;AACU,uBAAO;;;;;;AAClB,gBAAA,MAAM,CAAC,GAAP,CAAW,SAAX;AACA,qBAAK,YAAL,GAAoB,eAAe,CAAC,SAApC;;;;;;;;;;AAGD;AAED;;AAEG;;AAzEL;AAAA;AAAA,WA0Ee,sBAAU;;;;;;AACrB,gBAAA,MAAM,CAAC,GAAP,CAAW,YAAX;AACA,qBAAK,YAAL,GAAoB,eAAe,CAAC,aAApC;;;;;;;;;;AAGD;AAED;;;;;AAKG;;AAtFL;AAAA;AAAA,WAuFe,cAAK,OAAL,EAAsB,IAAtB,EAAqC;;;;;;;;;qBAC5C,I;;;;;kDACK,KAAK,MAAL,CAAY,WAAZ,CAAwB,OAAxB,EAAiC,IAAjC,C;;;;AAEY,uBAAM,KAAK,QAAL,EAAN;;;AAAb,gBAAA,U;AACN;AACM,gBAAA,Q,GAAW,UAAU,CAAC,GAAX,CAAe,UAAC,MAAD;AAAA,yBAAY,KAAI,CAAC,MAAL,CAAY,WAAZ,CAAwB,OAAxB,EAAiC,MAAjC,CAAZ;AAAA,iBAAf,C;;AAET,uBAAM,OAAO,CAAC,GAAR,CAAY,QAAZ,CAAN;;;iEAA6B,C;;;;;;;;;AAExC;AAED;;;;AAIG;;AAvGL;AAAA;AAAA,WAwGe,qBACX,QADW,EAC4D;;;;;;AAEvE,gBAAA,MAAM,CAAC,KAAP,CAAa,aAAb,EAA4B,QAA5B;AAEA,qBAAK,SAAL,CAAe,IAAf,CAAoB,QAApB;;;;;;;;;;AAGD;AAED;;;;AAIG;;AAtHL;AAAA;AAAA,WAuHe,wBACX,QADW,EAC2D;;;;;;AAEtE,gBAAA,MAAM,CAAC,GAAP,CAAW,gBAAX;AAEA,qBAAK,SAAL,GAAiB,KAAK,SAAL,CAAe,MAAf,CAAsB,UAAC,OAAD;AAAA,yBAAa,OAAO,KAAK,QAAzB;AAAA,iBAAtB,CAAjB;;;;;;;;;;AAGD;AA/HH;AAAA;AAAA,WAiIe,oBAAQ;;;;;;kDACZ,KAAK,WAAL,CAAiB,QAAjB,E;;;;;;;;;AACR;AAnIH;AAAA;AAAA,WAqIe,iBAAQ,OAAR,EAAwD;AAAA,UAApC,oBAAoC,uEAAJ,IAAI;;;;;;;AACnE,gBAAA,MAAM,CAAC,GAAP,CAAW,SAAX,EAAsB,aAAtB,EAAqC,OAArC;;AACA,uBAAM,KAAK,WAAL,CAAiB,OAAjB,CAAyB,OAAzB,CAAN;;;;AACA,uBAAM,KAAK,MAAL,CAAY,OAAO,CAAC,SAApB,CAAN;;;;;;;;;AACD;AAzIH;AAAA;AAAA,WA2Ie,oBAAW,eAAX,EAA6B;;;;;;AACxC,gBAAA,MAAM,CAAC,GAAP,CAAW,YAAX,EAAyB,eAAzB,EAA0C,eAA1C;;AACA,uBAAM,KAAK,WAAL,CAAiB,UAAjB,CAA4B,eAAe,CAAC,SAA5C,CAAN;;;qBACI,KAAK,M;;;;;;AACP,uBAAM,KAAK,MAAL,CAAY,+BAAZ,CAA4C,eAAe,CAAC,SAA5D,CAAN;;;;;;;;;AAEH;AAjJH;AAAA;AAAA,WAmJe,0BAAc;;;;;;AACzB,gBAAA,MAAM,CAAC,GAAP,CAAW,gBAAX;;AACA,uBAAM,KAAK,WAAL,CAAiB,cAAjB,EAAN;;;qBACI,KAAK,M;;;;;;AACP,uBAAM,KAAK,MAAL,CAAY,gCAAZ,EAAN;;;;;;;;;AAEH;AAED;;;;;AAKG;;AAhKL;AAAA;AAAA,WAiKkB,yBACd,OADc,EAEd,cAFc,EAEmB;;;;;;AAEjC,oBAAI,KAAK,SAAL,CAAe,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,kBAAA,MAAM,CAAC,IAAP,CAAY,iBAAZ,EAA+B,uBAA/B,EAAwD,IAAxD;AACD,iBAFD,MAEO;AACL,kBAAA,MAAM,CAAC,GAAP,CAAW,iBAAX,sBAA2C,KAAK,SAAL,CAAe,MAA1D,iBAA8E,IAA9E;AACD;;AAED,qBAAK,SAAL,CAAe,OAAf,CAAuB,UAAC,QAAD,EAAa;AAClC,kBAAA,QAAQ,CAAC,OAAD,EAAU,cAAV,CAAR;AACD,iBAFD;;;;;;;;;;AAKD;AAhLH;AAAA;AAAA,WAyDS,uBAAwB;;;;;;mDACtB,OAAO,CAAC,OAAR,CAAgB,KAAhB,C;;;;;;;;;AACR;AA3DH;;AAAA;AAAA","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from '../utils/Logger';\nimport { TransportType, TransportStatus } from '..';\nconst logger = new Logger('Transport');\n/**\n * @internalapi\n *\n *\n */\nexport class Transport {\n    constructor(name, client, peerManager) {\n        /**\n         * The type of the transport\n         */\n        this.type = TransportType.POST_MESSAGE;\n        /**\n         * The status of the transport\n         */\n        this._isConnected = TransportStatus.NOT_CONNECTED;\n        /**\n         * The listeners that will be notified when new messages are coming in\n         */\n        this.listeners = [];\n        this.name = name;\n        this.client = client;\n        this.peerManager = peerManager;\n    }\n    /**\n     * Return the status of the connection\n     */\n    get connectionStatus() {\n        return this._isConnected;\n    }\n    /**\n     * Returns a promise that resolves to true if the transport is available, false if it is not\n     */\n    static isAvailable() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.resolve(false);\n        });\n    }\n    /**\n     * Connect the transport\n     */\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('connect');\n            this._isConnected = TransportStatus.CONNECTED;\n            return;\n        });\n    }\n    /**\n     * Disconnect the transport\n     */\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('disconnect');\n            this._isConnected = TransportStatus.NOT_CONNECTED;\n            return;\n        });\n    }\n    /**\n     * Send a message through the transport\n     *\n     * @param message The message to send\n     * @param recipient The recipient of the message\n     */\n    send(message, peer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (peer) {\n                return this.client.sendMessage(message, peer);\n            }\n            else {\n                const knownPeers = yield this.getPeers();\n                // A broadcast request has to be sent everywhere.\n                const promises = knownPeers.map((peerEl) => this.client.sendMessage(message, peerEl));\n                return (yield Promise.all(promises))[0];\n            }\n        });\n    }\n    /**\n     * Add a listener to be called when a new message is received\n     *\n     * @param listener The listener that will be registered\n     */\n    addListener(listener) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('addListener', listener);\n            this.listeners.push(listener);\n            return;\n        });\n    }\n    /**\n     * Remove a listener\n     *\n     * @param listener\n     */\n    removeListener(listener) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('removeListener');\n            this.listeners = this.listeners.filter((element) => element !== listener);\n            return;\n        });\n    }\n    getPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.peerManager.getPeers(); // TODO: Fix type\n        });\n    }\n    addPeer(newPeer, _sendPairingResponse = true) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('addPeer', 'adding peer', newPeer);\n            yield this.peerManager.addPeer(newPeer); // TODO: Fix type\n            yield this.listen(newPeer.publicKey);\n        });\n    }\n    removePeer(peerToBeRemoved) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('removePeer', 'removing peer', peerToBeRemoved);\n            yield this.peerManager.removePeer(peerToBeRemoved.publicKey);\n            if (this.client) {\n                yield this.client.unsubscribeFromEncryptedMessage(peerToBeRemoved.publicKey);\n            }\n        });\n    }\n    removeAllPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('removeAllPeers');\n            yield this.peerManager.removeAllPeers();\n            if (this.client) {\n                yield this.client.unsubscribeFromEncryptedMessages();\n            }\n        });\n    }\n    /**\n     * Notify the listeners when a new message comes in\n     *\n     * @param message Message\n     * @param connectionInfo Context info about the connection\n     */\n    notifyListeners(message, connectionInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.listeners.length === 0) {\n                logger.warn('notifyListeners', '0 listeners notified!', this);\n            }\n            else {\n                logger.log('notifyListeners', `Notifying ${this.listeners.length} listeners`, this);\n            }\n            this.listeners.forEach((listener) => {\n                listener(message, connectionInfo);\n            });\n            return;\n        });\n    }\n}\n//# sourceMappingURL=Transport.js.map"]},"metadata":{},"sourceType":"module"}